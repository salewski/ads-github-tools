# -*- org -*-

#+STARTUP: hidestars oddeven lognotedone lognoteredeadline lognoterepeat

#+PRIORITIES: 1 2 3 4 5

# Note that "RESCHEDULE" is something of a "meta todo"; it's used for todos
# that need to be rescheduled - a flag for additional planning work to be done
# on that particular todo. Typical flow: TODO ==> RESCHEDULE ==> TODO

#+TODO: TODO(t!) IN_PROGRESS(p!) DELEGATED(D@/!) WAITING(w@/!) HOLD(h@/!) REOPENED(r@/!) RESCHEDULE(R@/!) | DONE(d@/!)
#+TODO: | CANCELED(c@/!)
#+TODO: | SKIPPED(s@/!)

#+DRAWERS: LOGBOOK PROPERTIES MISCNOTES

#+TAGS: cache github doc build

#+CATEGORY: personal

* ads-github-cache design notes                                :cache:github:

** filesystem based

*** Similar in spirit to the .git/objects/ database

    The 'git' source code is much better structured than what I envision the
    first iteration or three of these tools being. For the moment, I'm really
    just looking for the scrappiest caching mechanism that can work in the
    common case, without worrying too much about corner cases or otherwise
    making it rock solid or perfect. Our strategy in the short term will be:
    if in doubt, invalidate the cache and pull the data from upstream.


*** Structure consistent with XDG Specification (maybe, or optional)

    I'm actually on the fence with this one, but other users would likely
    expect it. There's a tradeoff between having a single directory beneath
    which all program-suite-related config and cache info is written and
    splitting out the config information and cached data beneath two entirely
    different subdirectories.

    The first scheme might look something like this:

    :    ~/.ads-github-tools.d/
    :    ~/.ads-github-tools.d/etc/ads-github-tools.conf
    :    ~/.ads-github-tools.d/var/cache/github-v3-objects/

    The second (XDG-compliant) might look something like this:

    :    ~/.config/
    :    ~/.cache/

    For the XDG-related bits, we could use the [[id:75c73633-b997-4f5f-a057-f2440ed8b1ab][xdgdirs]] tool to obtain the XDG
    base directories (as opposed to having to manually implement the full spec
    ourselves).

**** XDG-related links

***** XDG-related links general

      https://wiki.debian.org/XDGBaseDirectorySpecification

***** XDG-related links tools/libraries

****** xdgdirs: command line tool; emits output for various langs (lisp, bash, json, others)
       :PROPERTIES:
       :ID:       75c73633-b997-4f5f-a057-f2440ed8b1ab
       :END:

       http://www.gnuvola.org/software/xdgdirs/
       http://www.gnuvola.org/software/xdgdirs/xdgdirs.html
       http://www.gnuvola.org/software/xdgdirs/xdgdirs.pdf


****** Racket

       https://docs.racket-lang.org/basedir/index.html

       https://github.com/willghatch/racket-basedir


****** Rust

       https://github.com/whitequark/rust-xdg



*** Structure if we ignore the XDG thing (for now)

    :     ~/.ads-github-tools.d/var/cache/github-v3-objects/xx/.....

    If the checksum names the directory, then the file objects inside it would
    be:

    :    .../url-normalized   (single-line file with normalized url as content)
    :    .../data-blob        (whatever was contained in the payload of the http response body)
    :    .../etag             (the Etag value (duh!))
    :
    :    .../http-response-headers (the raw response headers received when the date was obtained.
    :                               Probably only useful for debugging, but who knows...)


** /user/repos lists more than just your forks and owned repos

   I learned over the weekend that the data returned from =/user/repos/=
   includes not only the repositories for which the authenticated user is an
   owner and his personal forks of other repos, but also all
   organization-owned repos that the user has access to (regardless of whether
   or not he has a personal fork of them).

   This means that a fundamental assumption that the '*-fetch-all-upstreams'
   and '*-merge-all-upstreams' program was making about the repositories list
   obtained from that endpoint -- namely that it represented repos that the
   user either owned or had forked from others -- is incorrect. The data
   returned is (potentially) a superset of that data.

   Users who are not part of any organizations would not be affected, as the
   author was not prior to becoming a member of an organization and tripping
   over the bug. The behavior of the '*-fetch-all-upstreams' tool was to treat
   a personal fork of an organization repo as a non-fork, and to attempt to
   fetch the org repos that the user had available to him for forking, but for
   which he had no personal fork actually created.

   I'm experimenting with getting this buttoned up; just wanted to record
   information about the issue.


* TODO [#2] implement proper autotools-based build for ads-github-tools project ([[https://github.com/salewski/ads-github-tools/issues/5][issue #5]]) :build:
  :LOGBOOK:
  - CREATED [2016-05-15 Sun 12:16]
  :END:
  :PROPERTIES:
  :ID:       ecb0580f-246a-49cf-b29e-cba6313c16e5
  :END:


* documentation improvements                                            :doc:

** TODO [#3] introduce man pages
   :LOGBOOK:
   - CREATED [2016-05-15 Sun 12:17]
   :END:

   + Background

     Once we have [[id:ecb0580f-246a-49cf-b29e-cba6313c16e5][a proper build system]] in place, we should use it to generate
     project-specific man pages. I'm thinking that most of these will be in
     the form of POD embedded in the Perl and Bash program files.

     We should also provide a top-level =ads-github-tools(7)= into page that
     provides metadata about the project, overview of the tools, etc.


* TODO [#4] =ads-github-fetch-all-upstreams= maybe allow fetching of non-github-repo 'upstream' remotes, as well
  :LOGBOOK:
  - CREATED [2016-05-15 Sun 12:13]
  :END:
