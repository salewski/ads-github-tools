#!/bin/bash -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <ads@salewski.email> </text>
# SPDX-License-Identifier: GPL-2.0-or-later
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software Foundation,
#     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,, USA.

# ads-github-repo-create.in: Manipulate a single GitHub repo: create a new
# GitHub repo with a given name and attributes (description, default branch,
# etc.).
#
# Origin story:
#
#     * issue #48: "contrilb/ads-gh-repo: turn into real tool"
#       https://github.com/salewski/ads-github-tools/issues/48
#
# Possible future direction:
#
#     * issue #51: "consider multi-subcommand model"
#       https://github.com/salewski/ads-github-tools/issues/51
#
#       Note that this program would likely change to participate in a
#       dispatch mechanism; the basic capability would still be the same. It
#       would be that higher-level dispatch mechanism that might subsume a
#       small amount of the functionality currently implemented in this
#       program (such a handling the global options).
#
declare -r PROG='ads-github-repo-create'

set -o pipefail

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered-in at build time

declare -r VERSION='@VERSION@'  # value filtered-in at build time

declare -r gl_const_build_date='@BUILD_DATE@'  # value filtered-in at build time
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
# declare -r gl_const_release="${VERSION}"


# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts

RE_BLANK='^[[:space:]]*$'
RE_EMPTY='^$'

RE_ALL_DIGITS='^[[:digit:]]+$'

RE_DECIMAL_NUMBER1='^[[:digit:]]+[.][[:digit:]]*$'
RE_DECIMAL_NUMBER2='^[[:digit:]]*[.][[:digit:]]+$'

RE_JSON_BOOLEAN='^(true|false)$'


# In those instances in which we need to auto-initialize the new repo, there
# is a noticeable delay between when we push to the repo and when an API query
# for that repo will reflect the data just pushed. It seems that the GitHub
# side is engineered to be "eventually consistent", and since we are working
# through two different interfaces (the API and git-push(1)) there is no hope
# for "read our own writes".
#
# The result of this situation, of course, is that querying the API for our
# repo too soon after doing a 'git push' can result in a bogus reponse. To
# work around the issue we simply sleep(1) $DATA_PROP_SECS to wait for the
# data to propagate after a 'git push' before attempting to query it via the
# API. (Patches welcome for better approaches, if there are any...)
#
# Empirical testing has shown that the magic number 4 is long enough to be
# effective, but short enough to be bearable. The default value for
# DATA_PROP_SECS is subject to change without warning, in response to
# additional real-world experience. In a lot of cases, the difference between
# .5 seconds and 1 second seems to be where the difference lies, but there are
# enough failures with that value that we have determined that using one
# second would leave us too close to the border line. In any event, adjust to
# suit; that's what the '--prop-secs=NUMBER' knob is there for.
#
DATA_PROP_SECS=4  # override with --prop-secs=NUMBER

# Keys are internal values used by the program; values are allowed names for
# user-specified formats.
declare -A LEGIT_OUTPUT_FORMAT_SYM_TO_NAME=()
LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['JSON']='json'  # -O json
LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['TEXT']='text'  # the default

DFLT_OUTPUT_FORMAT=${LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['TEXT']}

OUTPUT_FORMAT=    # set with '-O' (--output-format=WORD)

DO_AUTO_INIT_REPO=false  # override with '-a' (--auto-init)
DO_FORCE_REPLACE=false   # override with '--force-replace'

NEW_REPO_DESC=
HAVE_NEW_REPO_DESC=false

NEW_REPO_NAME=
HAVE_NEW_REPO_NAME=false

NEW_REPO_URL_HOMEPAGE=
HAVE_NEW_REPO_URL_HOMEPAGE=false

declare -r GIT_CFG_KEY_INIT_DFLT_BRANCH='init.defaultBranch'  # see git-config(1), git >= 2.28
declare -r GITHUB_DFLT_BRANCH_NAME='main'  # GitHub policy, since 2020-10-01

NEW_REPO_DFLT_BRANCH_NAME=
HAVE_NEW_REPO_DFLT_BRANCH_NAME=false
FLG_NEW_REPO_ISSUES_ENABLED=true    # override with -I (--disable-issues)
FLG_NEW_REPO_PROJECTS_ENABLED=true  # override with -P (--disable-projects)
FLG_NEW_REPO_WIKI_ENABLED=true      # override with -W (--disable-wiki)

FLG_NEW_REPO_IS_PUBLIC=true         # override with -p (--private)

# Folks using GitHub Enterprise might access their API at a different
# location, so we parameterize the base URL for the GitHub API. MAKE SURE THIS
# URL INDICATES HTTPS (not just HTTP -- you do not want your HTTP Basic Auth
# credentials being transmitted in cleartext!).
#
# This is NOT declared read-only here because there is some minor fixup that
# we attempt so users do not need to be concerned with whether or not the URL
# ends with a slash. For our purposes we need the value to end with a slash,
# and will add a slash to the end if it is not specified here.
#
declare    gl_const_github_api_base_url='https://api.github.com/'

# We'll help future-proof this program by explicitly requesting version 3 of
# the GitHub API (although it is still the default at the time of writing
# (2020-10)).
#
declare -r gl_const_http_accept_github_version='Accept: application/vnd.github.v3+json'


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

BC_PROG="${BC:-@BC_PROG@}"
# jq - command line JSON parser and manipulation language
#      see: https://github.com/stedolan/jq
#
JQ_PROG="${JQ:-@JQ_PROG@}"
RM_PROG="${RM:-@RM@}"

CAT_PROG="${CAT:-@CAT@}"
GIT_PROG="${GIT:-@GIT_PROG@}"
SED_PROG="${SED:-@SED@}"

CURL_PROG="${CURL:-@CURL_PROG@}"
DATE_PROG="${DATE:-@DATE_PROG@}"

MKTEMP_PROG="${MKTEMP:-@MKTEMP_PROG@}"

declare -a NEEDED_EXTERNAL_PROGS=(
    "${JQ_PROG}"
    "${RM_PROG}"

    "${CAT_PROG}"

    "${CURL_PROG}"

    "${MKTEMP_PROG}"
)

for ext_tool in "${NEEDED_EXTERNAL_PROGS[@]}"; do

    t_path=$(builtin type -p "${ext_tool}")
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to locate \"%s\" on PATH; bailing out\n" "${ext_tool}" 1>&2
        exit 1
    fi

    if $DEBUGGING; then
        printf "${PROG} (debug): path to external tool \"%s\": %s\n" "${ext_tool}" "${t_path}" 1>&2
    fi
done

# For needed internal progs, we will just expect them to be installed "next
# to" the current program.
#
# Note that the mechanism used here needs to work both "in-tree" and when
# installed. When working in-tree, the other in-tree versions of our internal
# tools must be found first (even if the tools are installed on the system).
#
t_script_dir=${0%/*}
AGH_WHOAMI_PROG="${t_script_dir}/ads-github-whoami"

declare -a NEEDED_INTERNAL_PROGS=(
    "${AGH_WHOAMI_PROG}"
)
for int_tool in "${NEEDED_INTERNAL_PROGS[@]}"; do
    if test -x "${int_tool}"; then :; else
        printf "${PROG} (error): was unable to locate internal tool: \"%s\"; bailing out\n" "${int_tool}" 1>&2
        exit 1
    fi
    if $DEBUGGING; then
        printf "${PROG} (debug): found internal tool: %s\n" "${int_tool}" 1>&2
    fi
done


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $DEBUGGING; then
            printf "${PROG} (debug): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

# FIXME: support a --team-id=NAME opt, to indicate the team that will be
#        granted access to this repository (valid only when creating a
#        repository in an organization).
#
# FIXME: consider supporint a --visibility=TYPE opt to allow
#        "public|private|internal".  Is only applicable to GitHub Enterprise
#        customers. Would also require that we make the create API call with
#        the 'nebula-preview' header:
#
#            Access: application/vnd.github.nebula-preview+json

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] [--] REPO_NAME

Create a new GitHub repository.

Mandatory arguments to long options are mandatory for short options too.

  -h, --help                 Print this help message on stdout
  -V, --version              Print the version of the program on stdout
  -a, --auto-init            Auto-initialize the repo with a minimal README.md file
      --prop-secs=NUMBER     Seconds to wait for GitHub data propagation before verifying
                               Default is 4 seconds.
                               Only relevant when -a (--auto-init) is in-effect.      
  -b, --default-branch=NAME  Specify the name to use for the default branch.
                               Implies -a (--auto-init).
  -d, --description=BLURB    Specify a short description blurb for the repo
      --force-replace        If repo already exists, attempt to replace it
                               (delete, then re-create; requires 'delete_repo' scope)
      --homepage=URL         Specify a URL with more information about the repo
  -I, --disable-issues       Disable GitHub issues for the new repo
  -P, --disable-projects     Disable GitHub projects for the new repo
  -O, --output-format=WORD   Emit output in the format specified by WORD [default: text]
                               Valid values for WORD include: 'text' and 'json'
  -p, --private              Make the repository a GitHub private repo (default is public)
  -v, --verbose              Print program progress messages on stderr. Specify multiple
                               times to increase verbosity: info, debug, and tracing (set -x)
  -W, --disable-wiki         Disable GitHub wiki feature for the new repo
      --                     Signals the end of options and disables further options processing.
                               Any remaining argument(s) will be interpretted as a repo name

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <ads@salewski.email>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}

# Checks if FORMAT_NAME is one of the legitimate names for an output format
# (all legit format names are present as values in our $LEGIT_OUTPUT_FORMAT_SYM_TO_NAME
# associative array).
#
# If the provided FORMAT_NAME is legit, then $OUTPUT_FORMAT will be set to its
# corresponding internal name (the corresponding key in $LEGIT_OUTPUT_FORMAT_SYM_TO_NAME).
#
# Otherwise a message is printed on stderr and the program exits with an error status.
#
# @param CLI_OPT_NAME - (required) The name of the command line option to which FORMAT_NAME was provided as an argument
#
# @param FORMAT_NAME  - (required) A a user-provided format name value.
#
f_set_output_format_or_die () {

    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local -r __cli_opt_name=$1
    local -r __format_name_to_check=$2

    # We will use this to display a comma-separated list of the legit options
    # in the event that we need to emit an error message.
    #
    local __t_flattened_format_opt_names=''

    for __t_key_name in "${!LEGIT_OUTPUT_FORMAT_SYM_TO_NAME[@]}"; do

        __t_legit_format_name="${LEGIT_OUTPUT_FORMAT_SYM_TO_NAME["${__t_key_name}"]}"

        if test "${__t_legit_format_name}" = "${__format_name_to_check}"; then
            OUTPUT_FORMAT=${__t_key_name}
            return 0  # success
        fi

        if test -n "${__t_flattened_format_opt_names}"; then
            __t_flattened_format_opt_names="${__t_flattened_format_opt_names}"', '  # append comma-space
        fi
        __t_flattened_format_opt_names="${__t_flattened_format_opt_names}${__t_legit_format_name}"
    done

    printf "${PROG} (error): invalid format name \"%s\" provided for '%s' option; valid values include: [%s]; bailing out\n" \
           "${__format_name_to_check}" \
           "${__cli_opt_name}"         \
           "${__t_flattened_format_opt_names}" 1>&2

    # This is the "...or die" part...
    exit 1
}

function f_set_opt_default_branch_name_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_branch_name=$1

    if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then
        printf "${PROG} (error): multiple default branch name options provided; only one accepted; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_branch_name}"; then
        printf "${PROG} (error): value provided for default branch name may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_branch_name}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for default branch name may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_DFLT_BRANCH_NAME=$t_branch_name
    HAVE_NEW_REPO_DFLT_BRANCH_NAME=true

    declare -r NEW_REPO_DFLT_BRANCH_NAME
    declare -r HAVE_NEW_REPO_DFLT_BRANCH_NAME

    if $BE_VERBOSE; then
        printf "${PROG} (info): specifying a default branch name implies -a (--auto-init)\n" 1>&2
        $DO_AUTO_INIT_REPO || DO_AUTO_INIT_REPO=true
    fi

    return 0  # success
}


function f_set_opt_new_repo_desc_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_desc=$1

    if $HAVE_NEW_REPO_DESC; then
        printf "${PROG} (error): multiple repo descriptions provided; only one may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    # XXX: These two checks might be controversial, as setting an empty string
    #      for the repo description could be viewed as being explicit. For
    #      now, we are going to insist that no '-d' (--description=BLURB)
    #      option be provided if that is the effect you want. By default, the
    #      GitHub API creates the repo with the description blurb set to
    #      null. Are there any legit use cases to want to change that
    #      explicitly to an empty or blank string?
    #
    if test -z "${t_desc}"; then
        printf "${PROG} (error): value provided for repo description may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_desc}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for repo description may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    # FIXME: Validate length of description text, once we determine what the
    #        maximum allowed value is allowed by the GitHub API (it is not
    #        documented).

    NEW_REPO_DESC=$t_desc
    HAVE_NEW_REPO_DESC=true

    declare -r NEW_REPO_DESC
    declare -r HAVE_NEW_REPO_DESC

    return 0  # success
}


function f_set_opt_new_repo_url_homepage_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_url_homepage=$1

    if $HAVE_NEW_REPO_URL_HOMEPAGE; then
        printf "${PROG} (error): multiple repo homepage URLs provided; only one may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_url_homepage}"; then
        printf "${PROG} (error): value provided for repo homepage URL may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_url_homepage}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for repo homepage URL may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_URL_HOMEPAGE=$t_url_homepage
    HAVE_NEW_REPO_URL_HOMEPAGE=true

    declare -r NEW_REPO_URL_HOMEPAGE
    declare -r HAVE_NEW_REPO_URL_HOMEPAGE

    return 0  # success
}


function f_set_opt_new_repo_name_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_repo_name=$1

    if $HAVE_NEW_REPO_NAME; then
        printf "${PROG} (error): only one REPO_NAME may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_repo_name}"; then
        printf "${PROG} (error): value provided for REPO_NAME may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_repo_name}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for REPO_NAME may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_NAME=$t_repo_name
    HAVE_NEW_REPO_NAME=true

    declare -r NEW_REPO_NAME
    declare -r HAVE_NEW_REPO_NAME

    return 0  # success
}


# URL-encode SOME_VALUE. Write the URL-encoded value to (global) output
# variable named by OUT_VAR_NAME.
#
# Uses curl(1) to perform the URL-encoding; does not make any network calls.
#
# Based on the technique posted here:
#
#     http://stackoverflow.com/questions/296536/urlencode-from-a-bash-script
#
# @param SOME_VALUE -- (required) The value to URL-encode
#
# @param OUT_VAR_NAME -- (required) the name of the global variable to which
#                        the URL-encoded output value should be written.
#
# @return 0 always, if it returns at all. All internal errors are fatal.
#
function f_url_encode () {
    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local __t_input_value=$1
    local __t_out_var_name=$2

    local __t_tmp

    if $DEBUGGING; then
        printf "${PROG} (debug): using curl(1) to url-encode value: \"%s\"\n" "${__t_input_value}" 1>&2
    fi
    __t_tmp=$("${CURL_PROG}" --silent           \
                             --output /dev/null \
                             --write-out '%{url_effective}'        \
                             --data-urlencode "${__t_input_value}" \
                             --get \
                             ''    \
                | "${SED_PROG}" -e 's/^..//'

              t_pipestatus=( ${PIPESTATUS[@]} )  # copy
              t_ps_sz=${#t_pipestatus[@]}
              t_estat_0=${t_pipestatus[0]}
              t_estat_1=${t_pipestatus[1]}
              if test ${t_estat_0} -ne 3 \
              || test ${t_estat_1} -ne 0; then
                  printf "${PROG} (error): [%d, %d] was unable to url-encode value (\"%s\") using curl(1); bailing out\n" \
                         ${t_estat_0} \
                         ${t_estat_1} \
                         "${t_input_value}" 1>&2
                  exit 1  # from subshell
              fi
              exit 0  # from subshell
             )
    if test $? -ne 0; then
        # error message already printed
        exit 1
    fi

    if $DEBUGGING; then
        printf "${PROG} (debug): url-encoded value is: \"%s\"\n" "${__t_tmp}" 1>&2
    fi

    printf -v "${__t_out_var_name}" '%s' "${__t_tmp}"
    if test $? -ne 0; then
        printf "${PROG} (error): ${FUNCNAME}(): was unable to write value to global var \"%s\"; bailing out\n" \
               "${__t_out_var_name}" 1>&2
        exit 1
    fi

    return 0  # success
}


# We will check for GIT_CFG_KEY in the user's personal configuration
# ("global"), and failing that will check at the ststem level ("system").
#
# If found, the value for the key will be written to the global variable named
# by OUT_VAR_NAME.
#
# We deliberately DO NOT check for the option in git-config(1) scopes
# "local" or "worktree". Those are specific to the exsiting repo in the
# current working directory (should the user happen to be invoking the
# command from an existing git working directory).
#
# This function is intended to obtain git config values, while ignoring the
# configuration (if any) that should not have any bearing on the attributes of
# the newly created GitHub repo that the current command is creating.
#
# @param GIT_CFG_KEY -- (required) the git-config(1) key to lookup
#
# @param OUT_VAR_NAME -- (required) the name of the global variable to which
#                        the output value should be written.
#
# @return 0 if value for key was wrtten to OUT_VAR_NAME; otherwise returns 1.
#
function f_get_git_config_opt_ignoring_local_repo () {
    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local __t_key=$1
    local __t_var=$2  # output variable

    local __t_tmp
    local __t_estat
    if $DEBUGGING; then
        printf "${PROG} (debug): checking git config (scope: \"global\") for key: \"%s\"\n" "${__t_key}" 1>&2
    fi
    # Recall that the exit status of git-config(1) will be 0 (zero) if the key
    # was found, and 1 (one) if the key is not found ("section or key is invalid").
    #
    __t_tmp=$("${GIT_PROG}" config --global --get "${__t_key}")
    __t_estat=$?
    if test ${__t_estat} -ne 0 \
    && test ${__t_estat} -ne 1; then
        printf "${PROG} (error): was unable to query git config (scope: \"global\") for key: \"%s\"; bailing out\n" "${__t_key}" 1>&2
        exit 1
    fi

    if test ${__t_estat} -eq 0; then
        if $DEBUGGING; then
            printf "${PROG} (debug): found git config key \"%s\" in scope \"global\"\n" "${__t_key}" 1>&2
        fi
    else
        if $DEBUGGING; then
            printf "${PROG} (debug): checking git config (scope: \"system\") for key: \"%s\"\n" "${__t_key}" 1>&2
        fi
        __t_tmp=$("${GIT_PROG}" config --system --get "${__t_key}")
        __t_estat=$?
        if test ${__t_estat} -ne 0 \
        && test ${__t_estat} -ne 1; then
            printf "${PROG} (error): was unable to query git config (scope: \"system\") for key: \"%s\"; bailing out\n" "${__t_key}" 1>&2
            exit 1
        fi
        if test ${__t_estat} -ne 0; then
            return 1  # key not found in either "global" or "system" scope
        fi
        if $DEBUGGING; then
            printf "${PROG} (debug): found git config key \"%s\" in scope \"system\"\n" "${__t_key}" 1>&2
        fi
    fi

    printf -v "${__t_var}" '%s' "${__t_tmp}"
    if test $? -ne 0; then
        printf "${PROG} (error): ${FUNCNAME}(): was unable to write value to global var \"%s\"; bailing out\n" "${__t_var}" 1>&2
        exit 1
    fi

    return 0  # success
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['auto-init']=0         # -a (--auto-init)
    ['default-branch']=1    # -b (--default-branch=NAME)
    ['description']=1       # -d (--description=BLURB)
    ['force-replace']=0     #    (--force-replace)
    ['homepage']=1          #    (--homepage=URL)

    ['disable-issues']=0    # -I (--disable-issues)
    ['disable-projects']=0  # -P (--disable-projects)
    ['disable-wiki']=0      # -W (--disable-wiki)

    ['output-format']=1     # -O (--output-format)

    ['private']=0           # -p (--private)
    ['prop-secs']=1         #    (--prop-secs=NUMBER)

    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVab:d:IO:PpvW' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

                # All of our command line options that accept arguments
                # require the values for those arguments to be non-empty
                # strings.
                if [[ "${OPTARG}" =~ $RE_BLANK ]]; then
                    printf "${PROG} (error): argument for option '--%s' may not be blank; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option --${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND

                    # All of our command line options that accept arguments
                    # require the values for those arguments to be non-empty
                    # strings.
                    if [[ "${OPTARG}" =~ $RE_BLANK ]]; then
                        printf "${PROG} (error): argument for option '--%s' may not be blank; bailing out\n" "${opt}" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;

            'auto-init' | 'a')
                DO_AUTO_INIT_REPO=true
                ;;

            'default-branch' | 'b')
                f_set_opt_default_branch_name_or_die "${OPTARG}"
                ;;

            'description' | 'd')
                f_set_opt_new_repo_desc_or_die "${OPTARG}"
                ;;

            'disable-issues' | 'I')
                FLG_NEW_REPO_ISSUES_ENABLED=false
                ;;

            'disable-projects' | 'P')
                FLG_NEW_REPO_PROJECTS_ENABLED=false
                ;;

            'disable-wiki' | 'W')
                FLG_NEW_REPO_WIKI_ENABLED=false
                ;;

            'force-replace')  # XXX: dangerous op
                DO_FORCE_REPLACE=true
                ;;

            'homepage')
                # Design note: There is no short form for this option. Two
                # natural choices might seem to be '-h' and '-H', but we do
                # not want to use either of those for this purpose.
                #
                #     * '-h' is already used as the short form for '--help',
                #       and from a usability perspective that use case is far
                #       more important for this one.
                #
                #     * '-H' might make sense in some other program, but here
                #       we are using capital letters for the short-form
                #       "--disable-FOO" options (see '-I', '-P', and '-W'),
                #       and specifying a home page does not fit into that
                #       scheme.
                #
                f_set_opt_new_repo_url_homepage_or_die "${OPTARG}"
                ;;

            'output-format' | 'O' )
                t_local_opt_string='-'"${opt}"  # correct for single-letter option name
                if test "${#opt}" -gt 1; then
                    t_local_opt_string='-'"${t_local_opt_string}"  # correct for long-form option name
                fi
                f_set_output_format_or_die "${t_local_opt_string}" "${OPTARG}"
                ;;

            'private' | 'p')
                FLG_NEW_REPO_IS_PUBLIC=false
                ;;

            'prop-secs' )
                if [[ "${OPTARG}" =~ $RE_ALL_DIGITS ]]; then
                    DATA_PROP_SECS=${OPTARG}
                elif [[ "${OPTARG}" =~ $RE_DECIMAL_NUMBER1 ]]; then
                    DATA_PROP_SECS=${OPTARG}
                elif [[ "${OPTARG}" =~ $RE_DECIMAL_NUMBER2 ]]; then
                    DATA_PROP_SECS=${OPTARG}
                else
                    printf "${PROG} (error): propagation seconds must be an integer or decimal number; got \"%s\"; bailing out\n" \
                           "${OPTARG}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                ;;

            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;


            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;
        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# sanity check
if $HAVE_NEW_REPO_NAME; then
    printf "${PROG} (BUG): new repo name set prematurely? (%s); bailing out\n" "${NEW_REPO_NAME}" 1>&2
    exit 1
fi
# The first non-option command argument is interpretted as the name of the new
# repository to create.
if test $# -lt 1; then
    printf "${PROG} (error): REPO_NAME not provided; bailing out\n" 1>&2
    f_print_help 1>&2
    exit 1
fi

f_set_opt_new_repo_name_or_die "$1"
shift

if test $# -gt 0; then
    printf "${PROG} (error): only one REPO_NAME may be specified; bailing out\n" 1>&2
    f_print_help 1>&2
    exit 1
fi


if test -z "${OUTPUT_FORMAT}"; then
    OUTPUT_FORMAT=$DFLT_OUTPUT_FORMAT
fi


if $DO_AUTO_INIT_REPO; then

    # We will be auto-initializing the repository, either because the user
    # explicitly asked us to ('-a', '--auto-init'), or implicitly asked us to
    # ('-b', '--default-branch=NAME').

    if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then :; else
        # The user did not specify on the command line a default branch name
        # to use, but (since git 2.28 (tagged as such on 2020-07-26)) a
        # preference may be available in the user's ~/.gitconfig file under
        # the key:
        #
        #     init.defaultBranch
        #
        # We will honor that setting, if it exists. If the setting does not
        # exist, then the default branch name will be whatever the GitHub API
        # uses by default. Prior to 2020-10-01, that value was 'master'. After
        # 2020-10-01, the value is 'main'.
        #
        # See also:
        #     * git-config(1) -- the entry for 'init.defaultBranch' (git >= 2.28)
        #
        #     * https://github.blog/2020-07-27-highlights-from-git-2-28/#introducing-init-defaultbranch
        #
        #     * https://github.blog/changelog/2020-08-26-set-the-default-branch-for-newly-created-repositories/
        #     * https://github.com/github/renaming
        #
        if $DEBUGGING; then
            printf "${PROG} (debug): no default branch specified on command line; will check git config for 'init.defaultBranch'\n" 1>&2
        fi

        declare t_key_name=$GIT_CFG_KEY_INIT_DFLT_BRANCH
        declare t_global_out_val
        f_get_git_config_opt_ignoring_local_repo "${t_key_name}" 't_global_out_val'

        if test $? -eq 1; then
            if $DEBUGGING; then
                printf "${PROG} (debug): did not find a git config value for key '%s' (okay; will use GitHub default: \"%s\")\n" \
                       "${t_key_name}"              \
                       "${GITHUB_DFLT_BRANCH_NAME}" \
                       1>&2
            fi
            NEW_REPO_DFLT_BRANCH_NAME=${GITHUB_DFLT_BRANCH_NAME}
            HAVE_NEW_REPO_DFLT_BRANCH_NAME=true
        else
            if test -z "${t_global_out_val}"; then
                printf "${PROG} (warning): found empty value for git config key '%s'; ignoring (will use GitHub default: \"%s\")\n" \
                       "${t_key_name}" \
                       "${GITHUB_DFLT_BRANCH_NAME}" 1>&2
                NEW_REPO_DFLT_BRANCH_NAME=${GITHUB_DFLT_BRANCH_NAME}
                HAVE_NEW_REPO_DFLT_BRANCH_NAME=true

            elif [[ "${t_global_out_val}" =~ $RE_BLANK ]]; then
                printf "${PROG} (warning): found blank value for git config key '%s'; ignoring (will use GitHub default: \"%s\")\n" \
                       "${t_key_name}" \
                       "${GITHUB_DFLT_BRANCH_NAME}" 1>&2
                NEW_REPO_DFLT_BRANCH_NAME=${GITHUB_DFLT_BRANCH_NAME}
                HAVE_NEW_REPO_DFLT_BRANCH_NAME=true

            else
                if $DEBUGGING; then
                    printf "${PROG} (debug): found a git config value for key '%s': \"%s\"\n" "${t_key_name}" "${t_global_out_val}" 1>&2
                fi
                NEW_REPO_DFLT_BRANCH_NAME=${t_global_out_val}
                HAVE_NEW_REPO_DFLT_BRANCH_NAME=true
            fi
        fi
        unset t_global_out_val
    fi

    # Internal sanity check
    if ${HAVE_NEW_REPO_DFLT_BRANCH_NAME}; then :; else
        printf "${PROG} (BUG) [line: $LINENO]: HAVE_NEW_REPO_DFLT_BRANCH_NAME should be true here; bailing out\n"
    fi
fi

:
: Key flags and options summary:
: ------------------------------
: "$PROG (trace: $LINENO): force-replace enabled?: ${DO_FORCE_REPLACE}"
: "$PROG (trace: $LINENO):        auto-init repo?: ${DO_AUTO_INIT_REPO}"
:
: "$PROG (trace: $LINENO):          output format: ${OUTPUT_FORMAT}"
:
: "$PROG (trace: $LINENO):     have new repo name: ${HAVE_NEW_REPO_NAME}"
: "$PROG (trace: $LINENO):    new repo name value: \"${NEW_REPO_NAME}\""
:
: "$PROG (trace: $LINENO):  have dflt branch name: ${HAVE_NEW_REPO_DFLT_BRANCH_NAME}"
: "$PROG (trace: $LINENO): dflt branch name value: \"${NEW_REPO_DFLT_BRANCH_NAME}\""
:
: "$PROG (trace: $LINENO):     have new repo desc: ${HAVE_NEW_REPO_DESC}"
: "$PROG (trace: $LINENO):    new repo desc value: \"${NEW_REPO_DESC}\""
:
: "$PROG (trace: $LINENO):  have new repo url homepage: ${HAVE_NEW_REPO_URL_HOMEPAGE}"
: "$PROG (trace: $LINENO): new repo url homepage value: \"${NEW_REPO_URL_HOMEPAGE}\""
:
: "$PROG (trace: $LINENO):   issues enabled?: ${FLG_NEW_REPO_ISSUES_ENABLED}"
: "$PROG (trace: $LINENO): projects enabled?: ${FLG_NEW_REPO_PROJECTS_ENABLED}"
: "$PROG (trace: $LINENO):     wiki enabled?: ${FLG_NEW_REPO_WIKI_ENABLED}"
:
: "$PROG (trace: $LINENO):   repo is public?: ${FLG_NEW_REPO_IS_PUBLIC}"


MY_TMP_DIR=$("${MKTEMP_PROG}" -t --directory "${PROG}.XXXXXXXX")
if test $? -ne 0; then
    printf "${PROG} (error) was unable to create temporary directory; bailing out\n" 1>&2
    exit 1
fi
#
# This should be a "can't happen" scenario, but since we do a 'rm -fr ...' on
# the value when we are done, we want to be belt-and-suspenders about it...
#
if test -z "${MY_TMP_DIR}"; then
    printf "${PROG} (error) temporary directory path is empty; bailing out\n" 1>&2
    exit 1
fi
function f_cleanup_rmfr_tmpdir () {
    local -a t_rm_opts=()
    t_rm_opts+=('-f')
    t_rm_opts+=('-r')
    if $TRACING; then
        t_rm_opts+=('-v')  # verbose
    fi
    "${RM_PROG}" "${t_rm_opts[@]}" "${MY_TMP_DIR}"
    # Ignore exit status -- Is a cleanup hook, so do not exit the process if
    # 'rm' failed; keep going...
}
F_CLEANUP_HOOK_NAMES+=( 'f_cleanup_rmfr_tmpdir' )

declare -r MY_TMP_CURL_OUT_FPATH="${MY_TMP_DIR}/curl.out"
declare -r MY_TMP_GIT_REPO_FPATH="${MY_TMP_DIR}/repo.git"

# Obtain the username (a.k.a. "owner" or "login") of the authenticated GitHub
# user.
GITHUB_REPO_OWNER=$("${AGH_WHOAMI_PROG}")
if test $? -ne 0; then
    printf "${PROG} (error): was unable to obtain the name of the authenticated GitHub user; bailing out\n" 1>&2
    exit 1
fi
if test -z "${GITHUB_REPO_OWNER}"; then
    printf "${PROG} (error): empty value obtained for name of the authenticated GitHub user; bailing out\n" 1>&2
    exit 1
fi
declare -r GITHUB_REPO_OWNER
if $BE_VERBOSE; then
    printf "${PROG} (info): GitHub repo owner is: %s\n" "${GITHUB_REPO_OWNER}" 1>&2
fi


# Create URL-encoded variations of our GITHUB_REPO_OWNER and NEW_REPO_NAME,
# both of which appear in URLs used for the GitHub v3 API.
#
declare    GITHUB_REPO_OWNER_URLENC
declare    NEW_REPO_NAME_URLENC
f_url_encode "${GITHUB_REPO_OWNER}" 'GITHUB_REPO_OWNER_URLENC'
f_url_encode "${NEW_REPO_NAME}"     'NEW_REPO_NAME_URLENC'
declare -r GITHUB_REPO_OWNER_URLENC
declare -r NEW_REPO_NAME_URLENC


# Build up our repository request JSON structure based on the configuration
# bits specified by the user and/or gathered from contextual info.
#
# The only key that is a required param by the GitHub API is 'name'.
#
# For non-boolean fields, we only specify a key/value pair if we have have
# gathered a value.
#
# Note that '-b' (--default-branch=NAME) implies '-a' (--auto-init). The
# reason for that is that we need to create a commit to reify the branch; a
# branch does not exist until a commit has been made to it.
#
# Note, too, that our '-a' (--auto-init) option is conceptually similar (read
# as: "nearly identical") to the GitHub v3 API's "auto_init" parameter for the
# repo creation endpoint, but ads-github-repo-create DOES NOT use the
# "auto_init" parameter (it /did/ use that parameter through commit
# acf77414be14598c0418a13e607a5718d65c34a5 (2020-10-07), but it was later
# found that the benefit of that attribute was not sufficient to merit its use
# over just performing the work (primarily) locally, which we can do both more
# efficiently and more robustly).
#
# For additional background on this choice, see the subsection named:
#
#     "Option '-a' (--auto-init) does not necessarily mean the "auto_init" parameter"
#
# in the write-up of issue #55:
#
#   * "repo-create: make repo auto-initialization optional"
#     https://github.com/salewski/ads-github-tools/issues/55
#
#
# FIXME: Consider supporting 'visibility' (public|private|internal).
#
#        - Would override the 'private' (true|false) param, if both were
#          provided.
#
#        - Would require using the 'nebula-preview' header:
#          Access: application/vnd.github.nebula-preview+json
#
json_create=$("${CAT_PROG}" - <<EOF
{
    "auto_init": "false",
    "name":      "${NEW_REPO_NAME}"
EOF
)

# XXX: Empirical testing against the GitHub v3 API revealed some wonkiness: if
#      you explicitly specify 'private:false', then the repo is created as
#      'private:true'.
#
#      But if you simply omit the 'private' key when you do not want a private
#      repo, then the repo is created as 'private:false'.
#
if $FLG_NEW_REPO_IS_PUBLIC; then :;
#    json_create="${json_create}, \"private\": \"false\""
else
    json_create="${json_create}, \"private\": \"true\""
fi

if $FLG_NEW_REPO_ISSUES_ENABLED; then
    json_create="${json_create}, \"has_issues\": \"true\""
else
    json_create="${json_create}, \"has_issues\": \"false\""
fi

# XXX: Empirical testing against the GitHub v3 API revealed some wonkiness: if
#      you explicitly specify 'has_projects:false', then the repo is created
#      as 'has_projects:true'.
#
#      Unlike the 'private' field above, there's not easy workaround for this
#      one other than checking what we get back later on and PATCHing the repo
#      with an update to achieve the desired end state.
#
if $FLG_NEW_REPO_PROJECTS_ENABLED; then
    json_create="${json_create}, \"has_projects\": \"true\""
else
    json_create="${json_create}, \"has_projects\": \"false\""
fi

if $FLG_NEW_REPO_WIKI_ENABLED; then
    json_create="${json_create}, \"has_wiki\": \"true\""
else
    json_create="${json_create}, \"has_wiki\": \"false\""
fi

if $HAVE_NEW_REPO_DESC; then
    json_create="${json_create}, \"description\": \"${NEW_REPO_DESC}\""
fi

if $HAVE_NEW_REPO_URL_HOMEPAGE; then
    json_create="${json_create}, \"homepage\": \"${NEW_REPO_URL_HOMEPAGE}\""
fi

# Writing in 2020-10, this one is not (yet?) honored by the repo creation API
# endpoint (but we have a workaround; see below).
if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then
    json_create="${json_create}, \"default_branch\": \"${NEW_REPO_DFLT_BRANCH_NAME}\""
fi

json_create="${json_create}"' }'  # close JSON object


: $PROG \(trace: $LINENO\): json_create: @@@[[[___"${json_create}"___]]]@@@


# XXX: At the time of writing (2020-10-04), the 'default_branch' param in the
#      above is ignored by the GitHub API at the time of repo creation, even
#      though a 'default_branch' key is returned in the response. The value of
#      the key in the response does not reflect the value we provided, so the
#      code below jumps through hoops to rename the branch locally, and then
#      synchronize the remote repo with the same changes.


# Common global options for use in every 'curl' invocation. Specific
# invocations will require additional options, but such usages should not
# modify this array.
#
declare -a MY_CURL_DEFAULT_OPTS=()
declare -a MY_CURL_OPTS=()

# This disables output of curl's progress meter /and/ output of error messages...
MY_CURL_DEFAULT_OPTS+=( '--silent' )
# ...but this re-enables output of the error messages.
MY_CURL_DEFAULT_OPTS+=( '--show-error' )


# Force use of TLS 1.2 (or later). Writing in 2016, all previous versions are
# known to be broken and susceptible to known attacks. Note that the
# '--tlsv1.2' option was added in curl 7.34.0
#
# This is absolutely essential since we're using HTTP Basic Auth (see below).
#
MY_CURL_DEFAULT_OPTS+=( '--tlsv1.2' )

# Allow ONLY https, for both the initial request and for redirects
MY_CURL_DEFAULT_OPTS+=( '--proto')
MY_CURL_DEFAULT_OPTS+=( 'https')
MY_CURL_DEFAULT_OPTS+=( '--proto-redir')
MY_CURL_DEFAULT_OPTS+=( 'https')


# Tell curl to use HTTP Basic Authentication. This is the curl default, but
# we're explicit about what we expect (and want to avoid any surprises from
# weirdo ~/.curlrc files).
#
# See also: RFC 7617 "The 'Basic' HTTP Authentication Scheme" (2015-09)
#
MY_CURL_DEFAULT_OPTS+=( '--basic' )


# User's authentication credentials will be obtained from the user's ~/.netrc
# file. See curl(1) and netrc(5)
#
MY_CURL_DEFAULT_OPTS+=( '--netrc'  )

MY_CURL_DEFAULT_OPTS+=( '--user-agent' )
MY_CURL_DEFAULT_OPTS+=( "$PROG"        )


# Even when we're just making HEAD requests, have curl fail
# MY_CURL_DEFAULT_OPTS+=( '--fail' )


# Tell the GitHub service that we're trying to speak v3 of the API. Writing in
# 2020, v3 is the default, but there is also a 'GraphQL API v4' version which
# we do not use here. Some newer version may become the default in the future,
# so we are explicit about which version we are using.
#
MY_CURL_DEFAULT_OPTS+=( '--header' )
MY_CURL_DEFAULT_OPTS+=( "${gl_const_http_accept_github_version}" )

# We always write the (JSON) output to a file in our temporary directory...
#
MY_CURL_DEFAULT_OPTS+=( '--output' )
MY_CURL_DEFAULT_OPTS+=( "${MY_TMP_CURL_OUT_FPATH}" )

# ...and write the HTTP response status to stdout. This allows for robust
# error handling. Also, we cannot really know how to interpret the output
# returned from the remote server until we have examined (at least) the HTTP
# response code.
#
MY_CURL_DEFAULT_OPTS+=( '--write-out'  )
MY_CURL_DEFAULT_OPTS+=( '%{http_code}' )


MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

MY_CURL_OPTS+=( '--get' )

# First check to see if the repo already exists. API responds with HTTP 200 on
# success (meaning repo was found to exist). The output (in our temporary
# 'curl.out' file) will be GitHub's JSON representation of the repository.
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}")
t_estat=$?

if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to retrieve existing repo; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

REPO_EXISTS=
NEED_TO_DELETE_EXISTING=false
case ${t_http_code} in

    '200')
        REPO_EXISTS=true

        if $DO_FORCE_REPLACE; then
            NEED_TO_DELETE_EXISTING=true
        else
            printf "${PROG} (error): GitHub repository already exists: %s/%s; will not delete\n    Use '--force-replace' to override\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            exit 1
        fi
        ;;

    '404')
        REPO_EXISTS=false
        # Keep going...
        ;;

    *)
        printf "${PROG} (error): HTTP response code was: \"%s\"; expected 200 (\"OK\"); bailing out\n" \
               "${t_http_code}" 1>&2
        exit 1
        ;;
esac

if ! ${REPO_EXISTS}; then

    if $BE_VERBOSE; then

        if ${DO_FORCE_REPLACE}; then
            # User explicitly requested that an existing repo be deleted, but
            # no existing repo was found. We'll emit a slightly different
            # message customized to this circumstance.
            #
            printf "${PROG} (info): deletion of existing GitHup repo requested, but repo does not exist: %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
        else
            printf "${PROG} (info): GitHub repository does not yet exist: %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
        fi
    fi
else
    # Repo exists, and the user wants us to delete it

    # Internal sanity checks
    if ${DO_FORCE_REPLACE}; then :; else
        printf "${PROG} (BUG): [line: ${LINENO}] DO_FORCE_REPLACE should be set here; bailing out\n" 1>&2
        exit 1
    fi
    if ${NEED_TO_DELETE_EXISTING}; then :; else
        printf "${PROG} (BUG): [line: ${LINENO}] NEED_TO_DELETE_EXISTING should be set here; bailing out\n" 1>&2
        exit 1
    fi

    if $BE_VERBOSE; then
        printf "${PROG} (info): as requested, will delete existing GitHup repo: %s/%s\n" \
               "${GITHUB_REPO_OWNER}" \
               "${NEW_REPO_NAME}" 1>&2
    fi

    MY_CURL_OPTS=()  # (re)set
    MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

    MY_CURL_OPTS+=( '--request' )  # -X
    MY_CURL_OPTS+=( 'DELETE' )

    # DELETE /repos/:owner/:repo
    #
    # Upon success, we will expect an HTTP 204 ("No Content") reponse.
    #
    # Possible expected errors include:
    #
    #
    #     404 ("Not Found") - If the repo does not exist. Though we checked
    #                         for the existence of the repo above, it would
    #                         still be possible for some other process to have
    #                         come along and deleted the repo since we
    #                         checked.
    #
    #     403 ("Forbidden") - If an organization owner has configured the
    #                         organization to prevent members from deleting
    #                         organization owned repos
    #
    # https://developer.github.com/v3/repos/#delete-a-repository
    # https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#delete-a-repository
    #
    t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                                 "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}" )
    t_estat=$?

    if test $t_estat -ne 0; then
        printf "${PROG} (error): was error while invoking curl(1) to DELETE existing repo; bailing out\n" 1>&2
        exit 1
    fi
    if test -z "${t_http_code}"; then
        printf "${PROG} (error): curl(1) DELETE command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
        exit 1
    fi

    case ${t_http_code} in

        '204')
            if $BE_VERBOSE; then
                printf "${PROG} (info): successfully deleted existing GitHup repo: %s/%s\n" \
                       "${GITHUB_REPO_OWNER}" \
                       "${NEW_REPO_NAME}" 1>&2
            fi
            ;;

        '403')
            printf "${PROG} (error): curl(1) DELETE resulted in a 403 (\"Forbidden\"); was unable to delete repo: %s/%s; bailing out\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            exit 1
            ;;

        '404')
            # This should only happen if some other process is attempting to
            # delete the repo at the same time we are, and that other process
            # beat us to it. Highly unlikely, except in contrived situations.
            #
            printf "${PROG} (warning): curl(1) DELETE resulted in a 404 (\"Not Found\"); existing GitHup repo deleted by some other means (not us): %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            # keep going...
            ;;

        *)
          printf "${PROG} (error): HTTP response code for DELETE command was: \"%s\"; expected 204 (\"No Content\"); bailing out\n" \
                 "${t_http_code}" 1>&2
          exit 1
          ;;
    esac
fi

MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

# Recall that the '--data' option implies an HTTP POST request.
#
MY_CURL_OPTS+=( '--data' )
MY_CURL_OPTS+=( "${json_create}" )

if $BE_VERBOSE; then
    printf "${PROG} (info): attempting to create new GitHup repo: %s/%s\n" \
           "${GITHUB_REPO_OWNER}" \
           "${NEW_REPO_NAME}" 1>&2
fi

# Create a new repository for the authenticated user. Note that that the
# literal string token 'user' in 'user/repos' is correct (it IS NOT supposed
# to be the name of the authenticated user; that is implied by the
# credentials)
#
# We are expecting an HTTP 201 if the new repository was successfully
# created. We'll treat any other response code as an error.
#
# If the repository already exists (and possibly other scenarios), the HTTP
# response code will be 422 ("Unprocessable Entity") [RFC 4918].
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}user/repos")
t_estat=$?
if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to create repo; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

if test '201' = "${t_http_code}"; then
    if $BE_VERBOSE; then
        printf "${PROG} (info): successfully created new GitHup repo: %s/%s\n" \
               "${GITHUB_REPO_OWNER}" \
               "${NEW_REPO_NAME}" 1>&2
    fi
else
    printf "${PROG} (error): HTTP response code was: \"%s\"; expected 201 (\"Created\"); bailing out\n" \
           "${t_http_code}" 1>&2
    exit 1
fi

if test -s "${MY_TMP_CURL_OUT_FPATH}"; then :; else
    printf "${PROG} (error): repo created, but JSON response not available; bailing out\n" 1>&2
    exit 1
fi


# XXX: Consider checking /every/ field from the response for deviations from
#      what was requested. Currently we check only the most critical bits.

read -r is_private is_fork dflt_branch_name \
  < <("${JQ_PROG}" -r '"\(.private) \(.fork) \(.default_branch)"' < "${MY_TMP_CURL_OUT_FPATH}")
if test $? -ne 0; then
    # Hopefully some other (more useful) error message was also emitted by
    # jq(1) or bash(1)...
    printf "${PROG} (error): was unable to extract data from JSON response; bailing out\n" 1>&2
    exit 1
fi

if [[ "${is_private}" =~ $RE_JSON_BOOLEAN ]]; then :; else
    printf "${PROG} (error): unrecognized value obtained for 'is_private': \"%s\"; bailing out\n" "${is_private}" 1>&2
    exit 1
fi
if [[ "${is_fork}" =~ $RE_JSON_BOOLEAN ]]; then :; else
    printf "${PROG} (error): unrecognized value obtained for 'is_fork': \"%s\"; bailing out\n" "${is_fork}" 1>&2
    exit 1
fi


# Sanity check: We just created the repo directly, so it should not look like
# a GitHub fork.
if test "${is_fork}" = 'false'; then :; else
    printf "${PROG} (error): 'is_fork' attribute on newly create repo expected to be 'true', but is: %s; bailing out\n" \
           "${is_fork}" 1>&2
    exit 1
fi

# Sanity check: Verify that the visibility of the repository reflects what we
# requested it to be.
if ${FLG_NEW_REPO_IS_PUBLIC}; then
    if test "${is_private}" = 'false'; then :; else
        printf "${PROG} (error): 'is_private' attribute on newly create repo expected to be 'false', but is: %s; bailing out\n" \
               "${is_private}" 1>&2
        exit 1
    fi
else
    if test "${is_private}" = 'true'; then :; else
        printf "${PROG} (error): 'is_private' attribute on newly create repo expected to be 'true', but is: %s; bailing out\n" \
               "${is_private}" 1>&2
        exit 1
    fi
fi


# Policy: The name of the default branch created by this tool will follow the
#         default GitHub policy, unless overridden by the command line
#         invocation or the local Git configuration.
#
# WANTED_BRANCH_NAME: Is the name the user wants to use as the default branch
#     name for the newly created repo, as expressed either explicitly on the
#     command line via the '-b' (--default-branch=NAME) option, or via
#     git-config(1) with the 'init.defaultBranch' setting. When the user has
#     not expressed such a preference by either of those means, then the value
#     of WANTED_BRANCH_NAME will be set to $GITHUB_DFLT_BRANCH_NAME (which is
#     always 'main'). WANTED_BRANCH_NAME expresses the name that should be
#     used for the default branch of the newly created repo when this program
#     is in control of setting it, which is only done when explicitly
#     requested with '-a' (--auto-init) or (implicitly) with '-b'
#     (--default-branch=NAME).
#
# EXPECTED_BRANCH_NAME is the name we expect the GitHub API to report as the
#     name of the newly created repo during our end-state verification step.
#
#     * When the user has specified '-a' (--auto-init) (either explicitly, or
#       implicitly by specifying '-b' (--default-branch=NAME)), then this
#       value will always be the same as $WANTED_BRANCH_NAME.
#
#     * When no auto-initialization was done for the repo, then the newly
#       created repo will be "empty", and will not actually have a default
#       branch (it will not have any branches). In this case, the GitHub API
#       indicates (in the 'default_branch' property) that the default branch
#       name is 'main'; that is because that is the name GitHub would have
#       used by default if we were to have allowed it to initialize the
#       repo. It is also the name a user would end up with if the GitHub repo
#       setup instructions are followed blindly (since those instructions were
#       updated on 2020-10-01).
#
WANTED_BRANCH_NAME=${GITHUB_DFLT_BRANCH_NAME}
EXPECTED_BRANCH_NAME=${GITHUB_DFLT_BRANCH_NAME}
if ${HAVE_NEW_REPO_DFLT_BRANCH_NAME}; then
    WANTED_BRANCH_NAME=${NEW_REPO_DFLT_BRANCH_NAME}
fi
if ${DO_AUTO_INIT_REPO} \
&& ${HAVE_NEW_REPO_DFLT_BRANCH_NAME}; then
    WANTED_BRANCH_NAME=${NEW_REPO_DFLT_BRANCH_NAME}
    EXPECTED_BRANCH_NAME=${NEW_REPO_DFLT_BRANCH_NAME}
fi
declare -r WANTED_BRANCH_NAME
declare -r EXPECTED_BRANCH_NAME


if $DO_AUTO_INIT_REPO; then

    # For repo auto-initialization and/or changing the default branch name of
    # the repo, we need a default branch to actually exist (a Git branch does
    # not exist until a commit to the branch is actually made).
    #
    # We will need to clone the empty repository and make an initial commit to
    # it in order to force the default branch into existence. The single
    # commit we make to the branch counts as our "repo auto-initialization".
    #
    # Beyond auto-initialization, if the user has requested that a default
    # branch name other than the GitHub default be used, then we rename the
    # branch locally, delete the 'origin' ref for HEAD, push the newly named
    # branch to GitHub (where it will be the only branch, so becomes the
    # default branch automatically), and then add the 'origin' ref for HEAD
    # pointing to the new branch.


    # Note that 'git clone --quiet ...' (as of git 2.28.0) always emits the
    # following warning on stderr:
    #
    #     warning: You appear to have cloned an empty repository.
    #
    # That's entirely expected and Officially Okay for our use case (and
    # others), so we will suppress that particular message to avoid suggesting
    # to the user that something may be amiss.
    #
    # XXX: This tweak does not account for any localization of the git warning
    #      that may produce a variant other than the US English that is
    #      currently accounted for.
    #
    if $BE_VERBOSE; then
        printf "${PROG} (info): [local repo] clone newly created (empty) repo..." 1>&2
    fi
    "${GIT_PROG}" clone --quiet 'git@github.com:'"${GITHUB_REPO_OWNER}/${NEW_REPO_NAME}.git" "${MY_TMP_GIT_REPO_FPATH}" \
        2> >( re_rmt='^warning:[[:space:]]+You appear to have cloned an empty repository[.]';
              while read -r line; do
                  if [[ "${line}" =~ $re_rmt ]]; then :; else
                      printf '%s\n' "${line}" 1>&2
                  fi
              done )
    if test $? -ne 0; then
        $BE_VERBOSE && printf '\n' 1>&2
        printf "${PROG} (error): was unable while trying to clone newly created repo; bailing out\n" 1>&2
        exit 1
    fi
    if $BE_VERBOSE; then
        printf '.done\n' 1>&2
    fi

    (
        cd "${MY_TMP_GIT_REPO_FPATH}"
        if test $? -ne 0; then
            printf "${PROG} (error): was unable to cd to directory of newly created repo; bailing out\n" 1>&2
            exit 1  # from subshell
        fi

        if $BE_VERBOSE; then
            printf "${PROG} (info): [local repo] repo auto-initialization..." 1>&2
        fi
        printf '# %s\n' "${NEW_REPO_NAME}" > 'README.md'
        if test $? -ne 0; then
            $BE_VERBOSE && printf '\n' 1>&2
            printf "${PROG} (error): repo auto-initalization: was unable to create to 'README.md' file; bailing out\n" 1>&2
            exit 1  # from subshell
        fi

        if $HAVE_NEW_REPO_DESC; then
            printf '%s\n' "${NEW_REPO_DESC}" >> 'README.md'
            if test $? -ne 0; then
                $BE_VERBOSE && printf '\n' 1>&2
                printf "${PROG} (error): repo auto-initalization: was unable to append repo desc to 'README.md' file; bailing out\n" 1>&2
                exit 1  # from subshell
            fi
        fi

        "${GIT_PROG}" add 'README.md'
        if test $? -ne 0; then
            $BE_VERBOSE && printf '\n' 1>&2
            printf "${PROG} (error): auto-initialization: was unable to add 'README.md' to git index; bailing out\n" 1>&2
            exit 1  # from subshell
        fi

        "${GIT_PROG}" commit --quiet --message='add file: README.md'
        if test $? -ne 0; then
            $BE_VERBOSE && printf '\n' 1>&2
            printf "${PROG} (error): auto-initialization: was unable to commit changes; bailing out\n" 1>&2
            exit 1  # from subshell
        fi
        if $BE_VERBOSE; then
            printf '.done\n' 1>&2
        fi

        # So we have our new repo checked-out and the content has been
        # auto-initialized locally. Before we push it up to GitHub, though, we
        # need to ensure the branch name is sane (for some definition of "sane"...)

        t_branch_name_as_created=$("${GIT_PROG}" symbolic-ref --quiet --short 'HEAD')
        if test $? -ne 0; then
            printf "${PROG} (error): auto-initialization: was unable to obtain name of branch as created; bailing out\n" 1>&2
            exit 1  # from subshell
        fi
        if test -z "${t_branch_name_as_created}"; then
            # Should be a "can't happen" scenario....
            printf "${PROG} (error): auto-initialization: obtained \"as created\" branch name is empty; bailing out\n" 1>&2
            exit 1  # from subshell
        fi

        # The user's local git version and configuration influence the name of
        # the "as created" branch. We will need to rename the "as created"
        # branch name under the following circumstances:
        #
        #     1. If the user explicitly requested a specific default branch
        #        name, and the "as created" branch name is different from that
        #        value, then we will rename the branch.
        #
        #     2. If the user did not explicitly request a specific default
        #        branch name but does have 'init.defaultBranch' configured,
        #        AND the "as created" branch name is different from the value
        #        specified by 'init.defaultBranch', then we will rename the
        #        branch.
        #
        #     3. If the user did not explicitly request a specific default
        #        branch name and DOES NOT have 'init.defaultBranch' set, then
        #        we will use 'main', which is the default branch name used by
        #        GitHub since 2020-10-01.

        # If we end up renaming the local branch, then there will be a little
        # extra housekeeping to do later on.
        RENAMED_THE_LOCAL_BRANCH=false
        if test "${t_branch_name_as_created}" = "${WANTED_BRANCH_NAME}"; then
            if $BE_VERBOSE; then
                printf "${PROG} (info): [local repo] auto-initialization: \"as created\" branch name (\"%s\") matches wanted name; no need to rename the branch\n" \
                       "${t_branch_name_as_created}" 1>&2
            fi
        else
            # Rename the branch
            #
            if $BE_VERBOSE; then
                printf "${PROG} (info): [local repo] auto-initialization: renaming \"as created\" branch \"%s\" to \"%s\"..." \
                       "${t_branch_name_as_created}" \
                       "${WANTED_BRANCH_NAME}" 1>&2
            fi
            "${GIT_PROG}" branch --move "${t_branch_name_as_created}" "${WANTED_BRANCH_NAME}"
            if test $? -ne 0; then
                $BE_VERBOSE && printf '\n' 1>&2
                printf "${PROG} (error): was unable to rename branch locally; bailing out\n" 1>&2
                exit 1  # from subshell
            fi
            if $BE_VERBOSE; then
                printf '.done\n' 1>&2
            fi

            if $BE_VERBOSE; then
                printf "${PROG} (info): [local repo] auto-initialization: deleting obsolete HEAD ref..." 1>&2
            fi
            "${GIT_PROG}" remote set-head origin --delete
            if test $? -ne 0; then
                $BE_VERBOSE && printf '\n' 1>&2
                printf "${PROG} (error): was unable to delete obsolete HEAD ref; bailing out\n" 1>&2
                exit 1  # from subshell
            fi
            if $BE_VERBOSE; then
                printf '.done\n' 1>&2
            fi

            RENAMED_THE_LOCAL_BRANCH=true
        fi

        # Whether or not we renamed the branch locally, the remote GitHub repo
        # does not yet have any branches in it. When we push our single branch
        # to GitHub, it will become the default branch by virtue of being the
        # first branch to exist in the repo.

        if $BE_VERBOSE; then
            printf "${PROG} (info): [local repo] auto-initialization: pushing branch to origin..." 1>&2
        fi
        # We jump through hoops to suppress 'remote:' messages without
        # suppresssing legit stderr messages.
        "${GIT_PROG}" push --quiet --set-upstream origin "${WANTED_BRANCH_NAME}" \
            2> >( re_rmt='^remote:';
                  while read -r line; do
                      if [[ "${line}" =~ $re_rmt ]]; then :; else
                          printf '%s\n' "${line}" 1>&2
                      fi
                  done ) \
            1> /dev/null
        if test $? -ne 0; then
            $BE_VERBOSE && printf '\n' 1>&2
            printf "${PROG} (error): auto-initialization: was unable to push new branch to origin; bailing out\n" 1>&2
            exit 1  # from subshell
        fi
        if $BE_VERBOSE; then
            printf '.done\n' 1>&2
        fi

        # If we renamed the branch above, then we will re-establish a HEAD ref
        # locally pointing at the new remote branch.
        #
        # Strictly speaking, this step is optional in this particular Git repo
        # clone because we will be delete it momentarily. Any new clones
        # created for the repo from GitHub would already have this ref set up
        # automatically (because at this point they would not be cloning an
        # empty repo). Nevertheless, we want our local repo to be in a sane
        # configuration for debugging purposes (while hacking on the code we
        # might disable the automatic repo deletion).
        #
        # Note that this will only succeed if the branch already exists for
        # our 'origin' remote, so we needed to push our branch to (and
        # implicitly sync with) our 'origin' remote before this command could
        # succeed:
        #
        if $RENAMED_THE_LOCAL_BRANCH; then
            if $BE_VERBOSE; then
                printf "${PROG} (info): [local repo] auto-initialization: establishing updated HEAD ref..." 1>&2
            fi
            "${GIT_PROG}" remote set-head origin "${WANTED_BRANCH_NAME}"
            if test $? -ne 0; then
                $BE_VERBOSE && printf '\n' 1>&2
                printf "${PROG} (error): was unable to establish updated HEAD ref; bailing out\n" 1>&2
                exit 1  # from subshell
            fi
            if $BE_VERBOSE; then
                printf '.done\n' 1>&2
            fi
        fi

        # XXX: So dumb....
        if $BE_VERBOSE; then
            printf "${PROG} (info): stalling %s seconds for \"eventually consistent\" data propagation..." \
                   "${DATA_PROP_SECS}" 1>&2
            # The shell wants to do integer math, so we'll just caveman it
            t_full_secs_left=${DATA_PROP_SECS%.*}
            t_frac_secs_left=${DATA_PROP_SECS#*.}
            if test -z "${t_full_secs_left}"; then
                t_full_secs_left=0
            fi
            if test -z "${t_frac_secs_left}"; then
                t_frac_secs_left=0
            fi
            # We will prefer the dot indicators, but that type of display does
            # not scale well so we will switch to using a spinner if we would
            # otherwise emit more than N dots.
            t_use_spinner=false
            if test ${t_full_secs_left} -gt 10; then
                t_use_spinner=true
            fi
            if $t_use_spinner; then
                t_spin='-\|/'
                t_modulus=${#t_spin}

                # We'll spin-tick three times each second to provide a more
                # visually pleasing animation than would be the case if we
                # only updated the spinner once each second.
                t_ticks_per_sec=3
                t_sleep_dur=$(printf '%s\n' 'scale=2' "1 / ${t_ticks_per_sec}" | "${BC_PROG}")
                if test $? -ne 0; then
                    printf "\n${PROG} (warning): was unable to calculate sleep duration; using .5\n" 1>&2
                    t_ticks_per_sec=2
                    t_sleep_dur='.5'
                    # keep going ...
                fi

                t_ii=0
                printf ' '  # advance into our own overwritable cell
                while test ${t_full_secs_left} -gt 0; do
                    t_idx=$(( (t_ii++) % t_modulus ))
                    printf '\b%s' "${t_spin:${t_idx}:1}"
                    sleep "${t_sleep_dur}"
                    if test $? -ne 0; then
                        printf "\n${PROG} (error): spinner sleep failed; bailing out\n" 1>&2
                        exit 1  # from subshell
                    fi
                    (( --t_full_secs_left ))
                done
            else
                # Use dot indicators
                while test ${t_full_secs_left} -gt 0; do
                    printf '.'
                    sleep 1
                    if test $? -ne 0; then
                        # Yes, this actually got triggered during development
                        printf "\n${PROG} (error): full-second sleep failed; bailing out\n" 1>&2
                        exit 1  # from subshell
                    fi
                    (( --t_full_secs_left ))
                done
            fi
            if test ${t_frac_secs_left} -gt 0; then
                if $t_use_spinner; then
                    printf '\b '  # backspace and space
                else
                    printf '.'
                fi
                sleep ".${t_frac_secs_left}"  # sleep for fraction of a second
                if test $? -ne 0; then
                    printf "\n${PROG} (error): sub-second sleep failed; bailing out\n" 1>&2
                    exit 1  # from subshell
                fi
            fi
            if $t_use_spinner; then
                printf '\b'
            fi
            printf '.done\n'
        fi

        exit 0  # from subshell
    )
    if test $? -ne 0; then
        # Error message already printed in subshell
        exit 1
    fi
fi


# At this point, our newly (re)created repo exists. Let's retrieve the view of
# it and present a summary (or the raw JSON, if so requested) to the user.

MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

MY_CURL_OPTS+=( '--get' )

# The API responds with HTTP 200 on success (meaning repo was found to
# exist). The output (in our temporary 'curl.out' file) will be GitHub's JSON
# representation of the repository.
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}")
t_estat=$?

if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to retrieve repo for summary purposes; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

case ${t_http_code} in

    '200')
        if $DEBUGGING; then
            printf "${PROG} (debug): successfully retrieved repo for summary purposes\n" 1>&2
        fi
        ;;

    '404')
        # Should only happen if some other process has come along and deleted
        # our new repo -- dueling banjos problem.
        printf "${PROG} (error): newly created repo does not exist(???); bailing out\n" 1>&2
        exit 1
        ;;

    *)
        printf "${PROG} (error): HTTP response code was: \"%s\"; expected 200 (\"OK\"); bailing out\n" \
               "${t_http_code}" 1>&2
        exit 1
        ;;
esac

if test "${OUTPUT_FORMAT}" = 'JSON'; then
    if test -s "${MY_TMP_CURL_OUT_FPATH}"; then :; else
        printf "${PROG} (error): JSON response is empty; bailing out\n" 1>&2
        exit 1
    fi

    "${CAT_PROG}" "${MY_TMP_CURL_OUT_FPATH}"
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to read JSON response from temporary file (\"%s\"); bailing out" \
               "${MY_TMP_CURL_OUT_FPATH}" 1>&2
        exit 1
    fi

    exit 0  # We're done
fi

if $DEBUGGING; then
    printf "${PROG} (debug): extracting fields from JSON response for summary purposes\n" 1>&2
fi

# NOTE: The 'description' field is read last because the value can contain
#       spaces; 'read' will clump them all into the last variable.
#
read -r  \
   ghr_name           \
   ghr_fork           \
\
   ghr_archived       \
   ghr_disabled       \
\
   ghr_created_at     \
   ghr_updated_at     \
\
   ghr_private        \
   ghr_visibility     \
\
   ghr_default_branch \
\
   ghr_has_issues     \
   ghr_has_projects   \
   ghr_has_wiki       \
\
   ghr_html_url       \
   ghr_homepage       \
   ghr_clone_url      \
   ghr_ssh_url        \
\
   ghr_owner_login    \
\
   ghr_description    \
  < <("${JQ_PROG}" -r ''\
'"\(if ((null == .name)           or ("" == .name))           then "-" else .name           end)'\
' \(if ((null == .fork)           or ("" == .fork))           then "-" else .fork           end)'\
\
' \(if ((null == .archived)       or ("" == .archived))       then "-" else .archived       end)'\
' \(if ((null == .disabled)       or ("" == .disabled))       then "-" else .disabled       end)'\
\
' \(if ((null == .created_at)     or ("" == .created_at))     then "-" else .created_at     end)'\
' \(if ((null == .updated_at)     or ("" == .updated_at))     then "-" else .updated_at     end)'\
\
' \(if ((null == .private)        or ("" == .private))        then "-" else .private        end)'\
' \(if ((null == .visibility)     or ("" == .visibility))     then "-" else .visibility     end)'\
\
' \(if ((null == .default_branch) or ("" == .default_branch)) then "-" else .default_branch end)'\
\
' \(if ((null == .has_issues)     or ("" == .has_issues))     then "-" else .has_issues     end)'\
' \(if ((null == .has_projects)   or ("" == .has_projects))   then "-" else .has_projects   end)'\
' \(if ((null == .has_wiki)       or ("" == .has_wiki))       then "-" else .has_wiki       end)'\
\
' \(if ((null == .html_url)       or ("" == .html_url))       then "-" else .html_url       end)'\
' \(if ((null == .homepage)       or ("" == .homepage))       then "-" else .homepage       end)'\
' \(if ((null == .clone_url)      or ("" == .clone_url))      then "-" else .clone_url      end)'\
' \(if ((null == .ssh_url)        or ("" == .ssh_url))        then "-" else .ssh_url        end)'\
\
' \(if ((null == .owner) or (null == .owner.login) or ("" == .owner.login)) then "-" else .owner.login end)'\
\
' \(if ((null == .description)    or ("" == .description))    then "-" else .description    end)'\
'"' < "${MY_TMP_CURL_OUT_FPATH}")
if test $? -ne 0; then
    # Hopefully some other (more useful) error message was also emitted by
    # jq(1) or bash(1)...
    printf "${PROG} (error): was unable to extract repo data from JSON response; bailing out\n" 1>&2
    exit 1
fi

:
: Extracted values from newly created repo:
: -----------------------------------------
: "$PROG (trace: $LINENO): ghr_name: ${ghr_name}"
: "$PROG (trace: $LINENO): ghr_fork: ${ghr_fork}"
:
: "$PROG (trace: $LINENO): ghr_archived: ${ghr_archived}"
: "$PROG (trace: $LINENO): ghr_disabled: ${ghr_disabled}"
:
: "$PROG (trace: $LINENO): ghr_created_at: ${ghr_created_at}"
: "$PROG (trace: $LINENO): ghr_updated_at: ${ghr_updated_at}"
:
: "$PROG (trace: $LINENO):    ghr_private: ${ghr_private}"
: "$PROG (trace: $LINENO): ghr_visibility: ${ghr_visibility}"
:
: "$PROG (trace: $LINENO): ghr_default_branch: ${ghr_default_branch}"
:
: "$PROG (trace: $LINENO):   ghr_has_issues: ${ghr_has_issues}"
: "$PROG (trace: $LINENO): ghr_has_projects: ${ghr_has_projects}"
: "$PROG (trace: $LINENO):     ghr_has_wiki: ${ghr_has_wiki}"
:
: "$PROG (trace: $LINENO):  ghr_html_url: ${ghr_html_url}"
: "$PROG (trace: $LINENO):  ghr_homepage: ${ghr_homepage}"
: "$PROG (trace: $LINENO): ghr_clone_url: ${ghr_clone_url}"
: "$PROG (trace: $LINENO):   ghr_ssh_url: ${ghr_ssh_url}"
:
: "$PROG (trace: $LINENO): ghr_owner_login: ${ghr_owner_login}"
:
: "$PROG (trace: $LINENO): ghr_description: ${ghr_description}"

if $DEBUGGING; then
    printf "${PROG} (debug): successfully extracted fields from JSON response\n" 1>&2
fi


if $DEBUGGING; then
    printf "${PROG} (debug): verifying attributes of newly created GitHub repo\n" 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: repo name..." 1>&2
fi
if test "${ghr_name}" = "${NEW_REPO_NAME}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected repo name to be \"%s\", but have \"%s\"; bailing out\n" \
           "${NEW_REPO_NAME}" \
           "${ghr_name}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi


if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'fork' flag..." 1>&2
fi
if test "${ghr_fork}" = 'false'; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'fork' flag to be \"false\", but have \"%s\"; bailing out\n" \
           "${ghr_fork}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi


if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'archived' flag..." 1>&2
fi
if test "${ghr_archived}" = 'false'; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'archived' flag to be \"false\", but have \"%s\"; bailing out\n" \
           "${ghr_archived}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'disabled' flag..." 1>&2
fi
if test "${ghr_disabled}" = 'false'; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'disabled' flag to be \"false\", but have \"%s\"; bailing out\n" \
           "${ghr_disabled}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

# XXX: Just testing that created_at and updated_at are non-zero in
#      length. Beef this up if real-world practice suggests that this is not
#      enough.
if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'created_at' field..." 1>&2
fi
if test -z "${ghr_created_at}"; then
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: the 'created_at' date/time field is empty; bailing out\n" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'updated_at' field..." 1>&2
fi
if test -z "${ghr_updated_at}"; then
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: the 'updated_at' field date/time is empty; bailing out\n" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'private' flag..." 1>&2
fi
# Note: comparing JSON boolean to 'true'/'false' command names
t_expected='false'  # GitHub repos are public by default
if ${FLG_NEW_REPO_IS_PUBLIC}; then :; else
    t_expected='true'
fi
if test "${ghr_private}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'private' flag to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_private}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'visibility' field..." 1>&2
fi
# t_expected='public'
# if ${FLG_NEW_REPO_IS_PUBLIC}; then :; else
#     # FIXME: There is also an experimental 'internal' value that we do not yet
#     #        support, so should not see here for a repo that we just created.
#     t_expected='private'
# fi
t_expected='-'  # When not opting-in to the experimental feature, the field is omitted or null in the repsonse
if test "${ghr_visibility}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'visibility' field to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_visibility}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'default_branch' field..." 1>&2
fi
t_expected=${EXPECTED_BRANCH_NAME}
if test "${ghr_default_branch}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'default_branch' field to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_default_branch}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'has_issues' flag..." 1>&2
fi
# Note: comparing JSON boolean to 'true'/'false' command names
t_expected=${FLG_NEW_REPO_ISSUES_ENABLED}
if test "${ghr_has_issues}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'has_issues' flag to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_has_issues}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'has_projects' flag..." 1>&2
fi
# Note: comparing JSON boolean to 'true'/'false' command names
t_expected=${FLG_NEW_REPO_PROJECTS_ENABLED}
if test "${ghr_has_projects}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    # FIXME: This setting is known to "not take"; may try harder via a follow-up PATCH operation?
    printf "${PROG} (warning): newly repo verification: expected 'has_projects' flag to be \"%s\", but have \"%s\" (known GitHub v3 API bug; ignoring)..." \
           "${t_expected}" \
           "${ghr_has_projects}" 1>&2
#    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'has_wiki' flag..." 1>&2
fi
# Note: comparing JSON boolean to 'true'/'false' command names
t_expected=${FLG_NEW_REPO_WIKI_ENABLED}
if test "${ghr_has_wiki}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'has_wiki' flag to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_has_wiki}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'html_url' field..." 1>&2
fi
# The GitHub API produces this value, but it should always be present and non-empty
if test -z "${ghr_html_url}"; then
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: the 'html_url' field is empty; bailing out\n" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'homepage' field..." 1>&2
fi
t_expected='-'  # our hard-coded transformation meaning "not present, or empty"
if ${HAVE_NEW_REPO_URL_HOMEPAGE}; then
    t_expected=${NEW_REPO_URL_HOMEPAGE}
fi
if test "${ghr_homepage}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'homepage' field to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_homepage}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'clone_url' field..." 1>&2
fi
# The GitHub API produces this value, but it should always be present and non-empty
if test -z "${ghr_clone_url}"; then
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: the 'clone_url' field is empty; bailing out\n" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'ssh_url' field..." 1>&2
fi
# The GitHub API produces this value, but it should always be present and non-empty
if test -z "${ghr_ssh_url}"; then
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: the 'ssh_url' field is empty; bailing out\n" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'owner.login' field..." 1>&2
fi
t_expected=${GITHUB_REPO_OWNER}
if test "${ghr_owner_login}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'owner.login' field to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_owner_login}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi

if $BE_VERBOSE; then
    printf "${PROG} (info): new repo verification: 'description' field..." 1>&2
fi
t_expected='-'  # our hard-coded transformation meaning "not present, or empty"
if ${HAVE_NEW_REPO_DESC}; then
    t_expected=${NEW_REPO_DESC}
fi
if test "${ghr_description}" = "${t_expected}"; then :; else
    $BE_VERBOSE && printf '\n' 1>&2
    printf "${PROG} (error): newly repo verification: expected 'description' field to be \"%s\", but have \"%s\"; bailing out\n" \
           "${t_expected}" \
           "${ghr_description}" 1>&2
    exit 1
fi
if $BE_VERBOSE; then
    printf '.ok\n' 1>&2
fi


if $DEBUGGING; then
    printf "${PROG} (debug): Emitting summary\n" 1>&2
fi

if $ghr_fork; then
    ghr_fork_disp='yes' # should never be the case
else
    ghr_fork_disp='no'
fi

if $ghr_archived; then
    ghr_archived_disp='yes'
else
    ghr_archived_disp='no'
fi

if $ghr_disabled; then
    ghr_disabled_disp='yes'
else
    ghr_disabled_disp='no'
fi

if $ghr_private; then
    ghr_private_disp='yes'
else
    ghr_private_disp='no'
fi

if $ghr_has_issues; then
    ghr_has_issues_disp='yes'
else
    ghr_has_issues_disp='no'
fi

# FIXME: This setting is known to "not take"; may try harder via a follow-up PATCH operation?
if $ghr_has_projects; then
    ghr_has_projects_disp='yes'
else
    ghr_has_projects_disp='no'
fi

if $ghr_has_wiki; then
    ghr_has_wiki_disp='yes'
else
    ghr_has_wiki_disp='no'
fi

if test '-' = "${ghr_created_at}"; then
    ghr_created_at_disp=${ghr_created_at}
else
    ghr_created_at_disp=$("${DATE_PROG}" --utc --date="${ghr_created_at}" '+%F %T%z')
    if test $? -ne 0; then
        printf "${PROG} (warning): was unable to format raw \"created at\" date; will show raw value\n" 1>&2
        ghr_created_at_disp=${ghr_created_at}
        # keep going
    fi
fi

if test '-' = "${ghr_updated_at}"; then
    ghr_updated_at_disp=${ghr_updated_at}
else
    ghr_updated_at_disp=$("${DATE_PROG}" --utc --date="${ghr_updated_at}" '+%F %T%z')
    if test $? -ne 0; then
        printf "${PROG} (warning): was unable to format raw \"updated at\" date; will show raw value\n" 1>&2
        ghr_updated_at_disp=${ghr_updated_at}
        # keep going
    fi
fi


t_was_auto_initialized_disp='no'
if ${DO_AUTO_INIT_REPO}; then
    t_was_auto_initialized_disp='yes'
fi


"${CAT_PROG}" - <<EOF
Summary of newly created repository:
                Name: ${ghr_name}
            Is fork?: ${ghr_fork_disp}
               Owner: ${ghr_owner_login}
        Is archived?: ${ghr_archived_disp}
        Is disabled?: ${ghr_disabled_disp}

          Created at: ${ghr_created_at_disp}
          Updated at: ${ghr_updated_at_disp}

         Is private?: ${ghr_private_disp}
          Visibility: ${ghr_visibility}

  Auto-initilalized?: ${t_was_auto_initialized_disp}
      Default branch: ${ghr_default_branch}

         Has issues?: ${ghr_has_issues_disp}
       Has projects?: ${ghr_has_projects_disp}
           Has wiki?: ${ghr_has_wiki_disp}

              GitHub: ${ghr_html_url}
            Homepage: ${ghr_homepage}
         Description: ${ghr_description}

       Clone via ssh: ${ghr_ssh_url}
     Clone via https: ${ghr_clone_url}
EOF

exit 0


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='ads-github-tools' \
#               --release='ads-github-tools-0.3.1' \
#               --section='1' \
#               > /outputdir/ads-github-repo-create.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=encoding utf8

=head1 NAME

  ads-github-repo-create - Create a new GitHub repository


=head1 SYNOPSIS

  ads-github-repo-create (-h | --help)
  ads-github-repo-create (-V | --version)
  ads-github-repo-create [(-v | --verbose)] [(-p | --private)] [--force-replace]
                         [(-O <word> | --output-format=<word>)]
                         [(-b <name> | --default-branch=<name>)]
                         [(-a | --auto-init)] [(-I | --disable-issues)]
                         [(-P | --disable-projects)] [(-W | --disable-wiki)]
                         [(-d <blurb> | --description=<blurb>)]
                         [--homepage=<url>] [--prop-secs=<number>)]
                         [--] REPO_NAME


=head1 DESCRIPTION

The C<ads-github-repo-create> program is part of the C<ads-github-tools>
project.

The C<ads-github-repo-create> program allows one to create a new GitHub
repository from the command line. Knobs are provided for configuring most of
the attributes that GitHub makes available for modification, as described
below.


=head1 OPTIONS

Below are the command line options currently accepted by
C<ads-github-repo-create>.


=over 4

=item --help

Print help usage message


=item -a, --auto-init

Request that the repository be automatically initialized with a minimal
'README.md' file.

Note that our C<-a> (C<--auto-init>) option is conceptually similar (read as:
"nearly identical") to the GitHub v3 API's C<"auto_init"> parameter for the
repo creation endpoint, but C<ads-github-repo-create> I<does not> use the
C<"auto_init"> API parameter.

=over

B<History:> The C<ads-github-repo-create> program I<did> use that parameter
through commit C<acf77414be14598c0418a13e607a5718d65c34a5> (2020-10-07), but
it was later found that the benefit of that attribute was not sufficient to
merit its use over just performing the work (primarily) locally, which can be
done more efficiently and more robustly.

=back

B<CAVEAT:> If you have an existing Git repository that you are trying to get
into GitHub, then you will probably want to avoid the repo auto-initialization
implied by this option. See the L</FAQ> section for more info.


=item -b, --default-branch=NAME

Specify the name to use for the default git branch.

If not specified, the value of the L<git-config(1)> C<init.defaultBranch> key
will be used (from the "global" or "system" scopes only), if
available. Otherwise the default used by GitHub will be applied; since
2020-10-01, that default branch name is C<main>.

This option implies the C<-a> (C<--auto-init>) option, as well.

B<CAVEAT:> If you have an existing Git repository that you are trying to get
into GitHub, then you will probably want to avoid the repo auto-initialization
implied by this option. See the L</FAQ> section for more info.


=item -d, --description=BLURB

Specify a short description blurb for the repo.


=item --force-replace

If a repo already exists with the specified name, the default behavior of the
program is to report the sitation in an error message and exit with a non-zero
status.

This option allows you to override that default behavior, and instead attempt
to replace the existing repository with a newly created one. The sequence of
operations performed to do so is basically a delete followed by a create.

Note that successfully performing this operation requires the use of a
personal access token that has the GitHub C<delete_repo> scope.


=item --homepage=URL

Specify a URL with more information about the repo. This is where you would
specify the URL to a related website.


=item -I, --disable-issues

Disable the GitHub issues feature for the new repo. By default, newly created
GitHub repositories have an associated "Issues" dashboard. If you do not need
it, then you can disable it at creation time using this option. Note that you
can always re-enable the issues dashboard at a later time.


=item -P, --disable-projects

Disable the GitHub projects feature for the new repo. By default, newly
created GitHub repositories have an associated "Projects" dashboard. If you do
not need it, then you can disable it at creation time using this option. Note
that you can always re-enable the projects dashboard at a later time.

=over 4

B<CAVEAT:> At the time of writing (2020-10), the GitHub v3 repo creation API
seems to be ignoring the C<has_projects> parameter key, so the projects
feature may not actually be disabled on the newly created repo. Since this
feature is not critical and likely won't see much use, the workaround for now
just is to carefully inspect the output of C<ads-github-repo-create>; if
needed, go into the GitHub web UI to disable the projects dashboard for the
newly created repo.

=back


=item -O, --output-format=WORD

Request that C<ads-github-repo-create> emit output in the format specified by
WORD.

Valid values for WORD include C<text> and C<json>.

The default, C<text>, is suitable for a human working in an interactive shell
session in a terminal.

The C<json> output shows the raw JSON representation for the newly created
repo, as provided by the GitHub API's endpoint:

    GET /repos/:owner/:repo

The C<json> output data structure contains more information than is presented
by the C<text> output.


=item -p, --private

Make the repository a GitHub private repo.

By default, newly created GitHub repositories are public. This option allows
you to request that the newly created repo have only private visibility,
instead.


=item --prop-secs=NUMBER

Specify the the amount of time that the program should "stall" between
performing a Git operation (such as C<git push ...>) and a GitHub API
operation to allow for data propagation within GitHub.

The default is four seconds, which was determined by empirical testing to be
usually adequate.

C<NUMBER> may be specified as a decimal to represent fractional seconds (e.g.,
'.5' or '10.5'); this capability is mainly useful during development and
testing of C<ads-github-repo-create> itself.

This option in only used when auto-initialization (C<-a>, C<--auto-init>) is
in-effect. Otherwise it has no effect.

=over 4

B<Background:> In those instances in which we need to auto-initialize the new
repo, there is a noticeable delay between when we push to the repo and when an
API query for that repo will reflect the data just pushed. Like many modern
systems, it seems that the GitHub side is engineered to be "eventually
consistent", and since we are working through two different interfaces (the
API and L<git-push(1)>) we cannot expect to immediately "read our own writes".

The result of this situation is that querying the API for our repo too soon
after doing a C<git push> can result in a reponse that contains stale data. To
work around the issue we simply L<sleep(1)> some number of seconds to allow
some time for the data to propagate within GitHub after we do a C<git push>
and before attempting to query it via the API. (Patches welcome for better
approaches, if there are any...)

Empirical testing has shown that the magic number four (seconds) is long
enough to be effective, but short enough to be bearable. This default value
for is subject to change without warning, in response to additional real-world
experience. If you find that the default value is too short, please let us
know (open a bug).

=back


=item -V, --version

Print the version of the program to stdout and then exit.


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
fruther the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item  -W, --disable-wiki

Disable the GitHub wiki feature for the new repo. By default, newly created
GitHub repositories have an associated wiki. If you do not need the wiki, then
you can disable it at creation time using this option. Note that you can
always re-enable the wiki at a later time.


=item --

Signals the end of options and disables further options processing. This can
(theoretically) be used to create a repository whose name would otherwise look
like a command line option to the C<ads-github-repo-create> program.

=back


=head1 EXIT STATUS

Exits with zero on success, non-zero on error.


=head1 EXAMPLES

=head2 Example 1: Default C<text> output with all default settings

This example shows the simplest invocation, which is simply to provide the
name of the new GitHub repository that is to be created:

    $ ads-github-repo-create 'aljunk-testing-repo-006'
    Summary of newly created repository:
                   Name: aljunk-testing-repo-006
               Is fork?: no
                  Owner: salewski
           Is archived?: no
           Is disabled?: no

             Created at: 2020-10-09 07:09:52+0000
             Updated at: 2020-10-09 07:09:56+0000

            Is private?: no
             Visibility: -

      Auto-initialized?: no
         Default branch: main

            Has issues?: yes
          Has projects?: yes
              Has wiki?: yes

                 GitHub: https://github.com/salewski/aljunk-testing-repo-006
               Homepage: -
            Description: -

          Clone via ssh: git@github.com:salewski/aljunk-testing-repo-006.git
        Clone via https: https://github.com/salewski/aljunk-testing-repo-006.git


=head2 Example 2: Default C<text> output with customized settings

This example requests: a private repo (C<-p>), a default branch named "whatev"
(C<-b>), that the issues and wiki features be disabled (C<-I> and C<-W>,
respectively), and that the new repo have "la la la" as its description
(C<-d>):

    $ ads-github-repo-create -p -b 'whatev' -I -W -d 'la la la' -- 'aljunk-testing-repo-007'
    Summary of newly created repository:
                   Name: aljunk-testing-repo-007
               Is fork?: no
                  Owner: salewski
           Is archived?: no
           Is disabled?: no

             Created at: 2020-10-09 07:12:03+0000
             Updated at: 2020-10-09 07:12:07+0000

            Is private?: yes
             Visibility: -

      Auto-initialized?: yes
         Default branch: whatev

            Has issues?: no
          Has projects?: yes
              Has wiki?: no

                 GitHub: https://github.com/salewski/aljunk-testing-repo-007
               Homepage: -
            Description: la la la

          Clone via ssh: git@github.com:salewski/aljunk-testing-repo-007.git
        Clone via https: https://github.com/salewski/aljunk-testing-repo-007.git


=head2 Example 3: Obtain JSON output representation of the new repo

This example shows how to request that the JSON representation of the newly
created repo be emitted (instead of the default text summary output). In this
example, we are piping the raw JSON into the L<jq(1)> tool for pretty printing
on our pager (L<less(1)>).

    $ ads-github-repo-create -O json -d 'la la la' -- 'aljunk-testing-repo-008' \
    >   | jq --color-output --indent 4 '.' | less -R
    {
        "id": 123456789,
        "node_id": "ABCdEFglcG9zaXLMnoPqRDM0Nj721Tc=",
        "name": "aljunk-test-repo-008",
        "full_name": "salewski/aljunk-test-repo-008",
        "private": false,
        "owner": {
            "login": "salewski",
    ...
    }


=head1 FAQ

Frequently Asked Questions (with answers!)

=over 4

=item *

B<Q:> I have an existing Git repo. Should I use C<-a> (C<--auto-init>) when
creating the repo in GitHub?

B<A:> No. If you have an existing Git repo, then you generally want to avoid
the auto-initialization of the repo when using C<ads-github-repo-create> to
create the repository on GitHub.

Explanation: Auto-initializing the GitHub repo will produce a commit, which
introduces a repo history that you will then need to work around with your
existing repo (via forcing a L<git-push(1)>, and other means).

In general, for a non-bare/non-mirror repo you would want to do something like
this:

    # cause an empty repo with the given name to exist in your GitHub account
    $ ads-github-repo-create --verbose -- my-repo-name
    ...

    $ cd /path/to/your/existing/git/repo

    $ git remote add gh-remote 'git@github.com:my-username/my-repo-name.git'

    $ git push --set-upstream --follow-tags gh-remote branch-foo branch-bar branch-baz

Or, to push all branches from the local repo, replace that the above
C<git-push(1)> command with this:

    $ git push --set-upstream --mirror gh-remote


=item *

B<Q:> I want to use a specific name for the default branch. Is
C<ads-github-repo-create> the right tool for the job?

B<A:> Yes, but whether or not you should use the C<-b>
(C<--default-branch=NAME>) option depends on the task context and what you are
trying to achieve.

Explanation: The C<-b> (C<--default-branch=NAME>) option implies C<-a>
(C<--auto-init>), and repo auto-initialization may or may not be appropriate
for the task at hand.

If you are starting a brand new project for which you do not yet have a Git
repo, then using C<-b> (C<--default-branch=NAME>) will likely be convenient
for you:

    $ ads-github-repo-create --verbose --default-branch=my-branch-name -- my-repo-name
    ...

    $ git clone 'git@github.com:my-username/my-repo-name.git'
    ...

    $ cd my-repo-name

    $ git symbolic-ref --quiet 'HEAD'
    refs/heads/my-branch-name

If you are starting a brand new project for which you do not yet have a Git
repo, but (for whatever reason) you want to start with an empty repository,
then avoid the C<-b> (C<--default-branch=NAME>) option. Instead, do something
like this:

    $ ads-github-repo-create --verbose -- my-repo-name
    ...

    $ git -c 'init.defaultBranch=my-branch-name' \
    >     clone 'git@github.com:my-username/my-repo-name.git'
    ...

    $ cd my-repo-name

    $ git symbolic-ref --quiet 'HEAD'
    refs/heads/my-branch-name

In the above set of commands, the name to be used for the default branch was
specified on the L<git-clone(1)> command line, by providing a value for the
C<init.defaultBranch> L<git-config(1)> key. Note that that key is only
available in Git >= 2.28.0 (released in Spring 2020). If you always want to
use a particular branch name as the default branch, then you would want to add
the setting to your Git configuration; then you would be able to omit the
C<-c KEY=VALUE> option in the above L<git-clone(1)> command.

=back


=head1 SEE ALSO

=over 4

=item * L<sleep(1)>, L<sleep(1posix)>

=item * L<ads-github-tools(7)>

=item * L<ads-github-whoami(1)>

Used to obtain the GitHub username of the authenticated user. The username
value (a.k.a. "owner" or "login") is used as a parameter in some of the GitHub
v3 API URLs that are invoked.


=item * L<git-config(1)>

=item * L<git-push(1)>

=item * L<jq(1)>

The C<jq> program is referenced in the L</EXAMPLES> section above. It is a
command line tool for transforming JSON in various ways. On Debian (and
Debian-derived) systems, it is available in the C<jq> package. The upstream
website for the tool is here:

=over 4

=item *

L<https://stedolan.github.io/jq/>

=back

and the source of the tool is available on GitHub here:

=over 4

=item *

L<https://github.com/stedolan/jq>

=back

=item * L<less(1)>

=back


=head1 HISTORY

The C<ads-github-repo-create> program first appeared in
C<ads-github-tools-0.3.1>, which was released in October 2020.


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <ads@salewski.email>

=back


=head1 BUGS

=over 4

=item * C<-P> (C<--disable-projects>) does not work

This is actually a bug in the GitHub v3 API. See caveat documented above for
the C<-P> (C<--disable-projects>) option.


=item * Repo description text length is not checked

The GitHub v3 API documentation does not specify the maximum length of the
C<description> parameter, noting only that it should be a "short description
of the repository". We could probably figure out the actual limit by
experimentation, and at the very least impose our own "reasonable"
limit. However, at the moment, any value provided on the command line is
submitted "as is".


=item * Does not support the parameter: C<team_id>

The GitHub v3 repo creation API has a C<team_id> paramater that allows the
caller to specify the id of the "team" that will be granted access to this
repository. The parameter is only valid when creating a repository in a GitHub
"organization", and is not currently supported by C<ads-github-repo-create>.


=item * Does not support the parameter: C<visibility=(public|private|internal)>

At the time of writing, the 'visibility' parameter is only in preview in the
GitHub v3 API. If this feature is important to you, feel free to open an issue
for it.

=back

There are probably tons of other bugs, too. If you find any, please report
them as described in the C<BUGS> file.


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut
