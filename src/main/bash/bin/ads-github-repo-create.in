#!/bin/bash -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <ads@salewski.email> </text>
# SPDX-License-Identifier: GPL-2.0-or-later
#
#     This program is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program; if not, write to the Free Software Foundation,
#     Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,, USA.

# ads-github-repo-create.in: Manipulate a single GitHub repo: create a new
# GitHub repo with a given name and attributes (description, default branch,
# etc.).
#
# Origin story:
#
#     * issue #48: "contrilb/ads-gh-repo: turn into real tool"
#       https://github.com/salewski/ads-github-tools/issues/48
#
# Possible future direction:
#
#     * issue #51: "consider multi-subcommand model"
#       https://github.com/salewski/ads-github-tools/issues/51
#
#       Note that this program would likely change to participate in a
#       dispatch mechanism; the basic capability would still be the same. It
#       would be that higher-level dispatch mechanism that might subsume a
#       small amount of the functionality currently implemented in this
#       program (such a handling the global options).
#
# TODO:
#     * honor the user's 'init.defaultBranch' setting (git >= 2.28 only)
#
declare -r PROG='ads-github-repo-create'

set -o pipefail

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered-in at build time

declare -r VERSION='@VERSION@'  # value filtered-in at build time

declare -r gl_const_build_date='@BUILD_DATE@'  # value filtered-in at build time
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
# declare -r gl_const_release="${VERSION}"


# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts

RE_BLANK='^[[:space:]]*$'
RE_EMPTY='^$'

RE_JSON_BOOLEAN='^(true|false)$'


# Keys are internal values used by the program; values are allowed names for
# user-specified formats.
declare -A LEGIT_OUTPUT_FORMAT_SYM_TO_NAME=()
LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['JSON']='json'  # -O json
LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['TEXT']='text'  # the default

DFLT_OUTPUT_FORMAT=${LEGIT_OUTPUT_FORMAT_SYM_TO_NAME['TEXT']}

OUTPUT_FORMAT=    # set with '-O' (--output-format=WORD)


DO_FORCE_REPLACE=false  # override with '--force-replace'

NEW_REPO_DESC=
HAVE_NEW_REPO_DESC=false

NEW_REPO_NAME=
HAVE_NEW_REPO_NAME=false

NEW_REPO_URL_HOMEPAGE=
HAVE_NEW_REPO_URL_HOMEPAGE=false

NEW_REPO_DFLT_BRANCH_NAME=
HAVE_NEW_REPO_DFLT_BRANCH_NAME=false
FLG_NEW_REPO_ISSUES_ENABLED=true    # override with -I (--disable-issues)
FLG_NEW_REPO_PROJECTS_ENABLED=true  # override with -P (--disable-projects)
FLG_NEW_REPO_WIKI_ENABLED=true      # override with -W (--disable-wiki)

FLG_NEW_REPO_IS_PUBLIC=true         # override with -p (--private)

# Folks using GitHub Enterprise might access their API at a different
# location, so we parameterize the base URL for the GitHub API. MAKE SURE THIS
# URL INDICATES HTTPS (not just HTTP -- you do not want your HTTP Basic Auth
# credentials being transmitted in cleartext!).
#
# This is NOT declared read-only here because there is some minor fixup that
# we attempt so users do not need to be concerned with whether or not the URL
# ends with a slash. For our purposes we need the value to end with a slash,
# and will add a slash to the end if it is not specified here.
#
declare    gl_const_github_api_base_url='https://api.github.com/'

# We'll help future-proof this program by explicitly requesting version 3 of
# the GitHub API (although it is still the default at the time of writing
# (2020-10)).
#
declare -r gl_const_http_accept_github_version='Accept: application/vnd.github.v3+json'


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

# jq - command line JSON parser and manipulation language
#      see: https://github.com/stedolan/jq
#
JQ_PROG="${JQ:-@JQ_PROG@}"
RM_PROG="${RM:-@RM@}"

CAT_PROG="${CAT:-@CAT@}"
GIT_PROG="${GIT:-@GIT_PROG@}"
SED_PROG="${SED:-@SED@}"

CURL_PROG="${CURL:-@CURL_PROG@}"
DATE_PROG="${DATE:-@DATE_PROG@}"

MKTEMP_PROG="${MKTEMP:-@MKTEMP_PROG@}"

declare -a NEEDED_EXTERNAL_PROGS=(
    "${JQ_PROG}"
    "${RM_PROG}"

    "${CAT_PROG}"

    "${CURL_PROG}"

    "${MKTEMP_PROG}"
)

for ext_tool in "${NEEDED_EXTERNAL_PROGS[@]}"; do

    t_path=$(builtin type -p "${ext_tool}")
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to locate \"%s\" on PATH; bailing out\n" "${ext_tool}" 1>&2
        exit 1
    fi

    if $DEBUGGING; then
        printf "${PROG} (debug): path to external tool \"%s\": %s\n" "${ext_tool}" "${t_path}" 1>&2
    fi
done

# For needed internal progs, we will just expect them to be installed "next
# to" the current program.
#
# Note that the mechanism used here needs to work both "in-tree" and when
# installed. When working in-tree, the other in-tree versions of our internal
# tools must be found first (even if the tools are installed on the system).
#
t_script_dir=${0%/*}
AGH_WHOAMI_PROG="${t_script_dir}/ads-github-whoami"

declare -a NEEDED_INTERNAL_PROGS=(
    "${AGH_WHOAMI_PROG}"
)
for int_tool in "${NEEDED_INTERNAL_PROGS[@]}"; do
    if test -x "${int_tool}"; then :; else
        printf "${PROG} (error): was unable to locate internal tool: \"%s\"; bailing out\n" "${int_tool}" 1>&2
        exit 1
    fi
    if $DEBUGGING; then
        printf "${PROG} (debug): found internal tool: %s\n" "${int_tool}" 1>&2
    fi
done


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $DEBUGGING; then
            printf "${PROG} (debug): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

# FIXME: support a --team-id=NAME opt, to indicate the team that will be
#        granted access to this repository (valid only when creating a
#        repository in an organization).
#
# FIXME: consider supporint a --visibility=TYPE opt to allow
#        "public|private|internal".  Is only applicable to GitHub Enterprise
#        customers. Would also require that we make the create API call with
#        the 'nebula-preview' header:
#
#            Access: application/vnd.github.nebula-preview+json

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] [--] REPO_NAME

Create a new GitHub repository.

Mandatory arguments to long options are mandatory for short options too.

  -h, --help                 Print this help message on stdout

  -V, --version              Print the version of the program on stdout

  -b, --default-branch=NAME  Specify the name to use for the default branch

  -d, --description=BLURB    Specify a short description blurb for the repo

      --force-replace        If repo already exists, attempt to replace it
                               (delete, then re-create)

      --homepage=URL         Specify a URL with more information about the repo

  -I, --disable-issues       Disable GitHub issues for the new repo

  -P, --disable-projects     Disable GitHub projects for the new repo

  -O, --output-format=WORD   Emit output in the format specified by WORD [default: text]
                               Valid values for WORD include: 'text' and 'json'

  -p, --private              Make the repository a GitHub private repo (default is public)

  -v, --verbose              Print program progress messages on stderr. Specify multiple
                               times to increase verbosity: info, debug, and tracing (set -x)

  -W, --disable-wiki         Disable GitHub wiki feature for the new repo

      --                     Signals the end of options and disables further options processing.
                               Any remaining argument(s) will be interpretted as a repo name

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <ads@salewski.email>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}

# Checks if FORMAT_NAME is one of the legitimate names for an output format
# (all legit format names are present as values in our $LEGIT_OUTPUT_FORMAT_SYM_TO_NAME
# associative array).
#
# If the provided FORMAT_NAME is legit, then $OUTPUT_FORMAT will be set to its
# corresponding internal name (the corresponding key in $LEGIT_OUTPUT_FORMAT_SYM_TO_NAME).
#
# Otherwise a message is printed on stderr and the program exits with an error status.
#
# @param CLI_OPT_NAME - (required) The name of the command line option to which FORMAT_NAME was provided as an argument
#
# @param FORMAT_NAME  - (required) A a user-provided format name value.
#
f_set_output_format_or_die () {

    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local -r __cli_opt_name=$1
    local -r __format_name_to_check=$2

    # We will use this to display a comma-separated list of the legit options
    # in the event that we need to emit an error message.
    #
    local __t_flattened_format_opt_names=''

    for __t_key_name in "${!LEGIT_OUTPUT_FORMAT_SYM_TO_NAME[@]}"; do

        __t_legit_format_name="${LEGIT_OUTPUT_FORMAT_SYM_TO_NAME["${__t_key_name}"]}"

        if test "${__t_legit_format_name}" = "${__format_name_to_check}"; then
            OUTPUT_FORMAT=${__t_key_name}
            return 0  # success
        fi

        if test -n "${__t_flattened_format_opt_names}"; then
            __t_flattened_format_opt_names="${__t_flattened_format_opt_names}"', '  # append comma-space
        fi
        __t_flattened_format_opt_names="${__t_flattened_format_opt_names}${__t_legit_format_name}"
    done

    printf "${PROG} (error): invalid format name \"%s\" provided for '%s' option; valid values include: [%s]; bailing out\n" \
           "${__format_name_to_check}" \
           "${__cli_opt_name}"         \
           "${__t_flattened_format_opt_names}" 1>&2

    # This is the "...or die" part...
    exit 1
}

function f_set_opt_default_branch_name_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_branch_name=$1

    if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then
        printf "${PROG} (error): multiple default branch name options provided; only one accepted; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_branch_name}"; then
        printf "${PROG} (error): value provided for default branch name may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_branch_name}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for default branch name may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_DFLT_BRANCH_NAME=$t_branch_name
    HAVE_NEW_REPO_DFLT_BRANCH_NAME=true

    declare -r NEW_REPO_DFLT_BRANCH_NAME
    declare -r HAVE_NEW_REPO_DFLT_BRANCH_NAME

    return 0  # success
}


function f_set_opt_new_repo_desc_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_desc=$1

    if $HAVE_NEW_REPO_DESC; then
        printf "${PROG} (error): multiple repo descriptions provided; only one may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    # XXX: These two checks might be controversial, as setting an empty string
    #      for the repo description could be viewed as being explicit. For
    #      now, we are going to insist that no '-d' (--description=BLURB)
    #      option be provided if that is the effect you want. By default, the
    #      GitHub API creates the repo with the description blurb set to
    #      null. Are there any legit use cases to want to change that
    #      explicitly to an empty or blank string?
    #
    if test -z "${t_desc}"; then
        printf "${PROG} (error): value provided for repo description may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_desc}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for repo description may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    # FIXME: Validate length of description text, once we determine what the
    #        maximum allowed value is allowed by the GitHub API (it is not
    #        documented).

    NEW_REPO_DESC=$t_desc
    HAVE_NEW_REPO_DESC=true

    declare -r NEW_REPO_DESC
    declare -r HAVE_NEW_REPO_DESC

    return 0  # success
}


function f_set_opt_new_repo_url_homepage_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_url_homepage=$1

    if $HAVE_NEW_REPO_URL_HOMEPAGE; then
        printf "${PROG} (error): multiple repo homepage URLs provided; only one may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_url_homepage}"; then
        printf "${PROG} (error): value provided for repo homepage URL may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_url_homepage}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for repo homepage URL may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_URL_HOMEPAGE=$t_url_homepage
    HAVE_NEW_REPO_URL_HOMEPAGE=true

    declare -r NEW_REPO_URL_HOMEPAGE
    declare -r HAVE_NEW_REPO_URL_HOMEPAGE

    return 0  # success
}


function f_set_opt_new_repo_name_or_die () {
    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local t_repo_name=$1

    if $HAVE_NEW_REPO_NAME; then
        printf "${PROG} (error): only one REPO_NAME may be specified; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    if test -z "${t_repo_name}"; then
        printf "${PROG} (error): value provided for REPO_NAME may not be empty; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi
    if [[ "${t_repo_name}" =~ $RE_BLANK ]]; then
        printf "${PROG} (error): value provided for REPO_NAME may not be blank; bailing out\n" 1>&2
        f_print_help 1>&2
        exit 1
    fi

    NEW_REPO_NAME=$t_repo_name
    HAVE_NEW_REPO_NAME=true

    declare -r NEW_REPO_NAME
    declare -r HAVE_NEW_REPO_NAME

    return 0  # success
}


# URL-encode SOME_VALUE. Write the URL-encoded value to (global) output
# variable named by OUT_VAR_NAME.
#
# Uses curl(1) to perform the URL-encoding; does not make any network calls.
#
# Based on the technique posted here:
#
#     http://stackoverflow.com/questions/296536/urlencode-from-a-bash-script
#
# @param SOME_VALUE -- (required) The value to URL-encode
#
# @param OUT_VAR_NAME -- (required) the name of the global variable to which
#                        the URL-encoded output value should be written.
#
# @return 0 always, if it returns at all. All internal errors are fatal.
#
function f_url_encode () {
    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local __t_input_value=$1
    local __t_out_var_name=$2

    local __t_tmp

    if $DEBUGGING; then
        printf "${PROG} (debug): using curl(1) to url-encode value: \"%s\"\n" "${__t_input_value}" 1>&2
    fi
    __t_tmp=$("${CURL_PROG}" --silent           \
                             --output /dev/null \
                             --write-out '%{url_effective}'        \
                             --data-urlencode "${__t_input_value}" \
                             --get \
                             ''    \
                | "${SED_PROG}" -e 's/^..//'

              t_pipestatus=( ${PIPESTATUS[@]} )  # copy
              t_ps_sz=${#t_pipestatus[@]}
              t_estat_0=${t_pipestatus[0]}
              t_estat_1=${t_pipestatus[1]}
              if test ${t_estat_0} -ne 3 \
              || test ${t_estat_1} -ne 0; then
                  printf "${PROG} (error): [%d, %d] was unable to url-encode value (\"%s\") using curl(1); bailing out\n" \
                         ${t_estat_0} \
                         ${t_estat_1} \
                         "${t_input_value}" 1>&2
                  exit 1  # from subshell
              fi
              exit 0  # from subshell
             )
    if test $? -ne 0; then
        # error message already printed
        exit 1
    fi

    if $DEBUGGING; then
        printf "${PROG} (debug): url-encoded value is: \"%s\"\n" "${__t_tmp}" 1>&2
    fi

    printf -v "${__t_out_var_name}" '%s' "${__t_tmp}"
    if test $? -ne 0; then
        printf "${PROG} (error): ${FUNCNAME}(): was unable to write value to global var \"%s\"; bailing out\n" \
               "${__t_out_var_name}" 1>&2
        exit 1
    fi

    return 0  # success
}


# We will check for GIT_CFG_KEY in the user's personal configuration
# ("global"), and failing that will check at the ststem level ("system").
#
# If found, the value for the key will be written to the global variable named
# by OUT_VAR_NAME.
#
# We deliberately DO NOT check for the option in git-config(1) scopes
# "local" or "worktree". Those are specific to the exsiting repo in the
# current working directory (should the user happen to be invoking the
# command from an existing git working directory).
#
# This function is intended to obtain git config values, while ignoring the
# configuration (if any) that should not have any bearing on the attributes of
# the newly created GitHub repo that the current command is creating.
#
# @param GIT_CFG_KEY -- (required) the git-config(1) key to lookup
#
# @param OUT_VAR_NAME -- (required) the name of the global variable to which
#                        the output value should be written.
#
# @return 0 if value for key was wrtten to OUT_VAR_NAME; otherwise returns 1.
#
function f_get_git_config_opt_ignoring_local_repo () {
    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
            $# ${__required_count} 1>&2
        exit 1
    fi

    local __t_key=$1
    local __t_var=$2  # output variable

    local __t_tmp
    local __t_estat
    if $DEBUGGING; then
        printf "${PROG} (debug): checking git config (scope: \"global\") for key: \"%s\"\n" "${__t_key}" 1>&2
    fi
    # Recall that the exit status of git-config(1) will be 0 (zero) if the key
    # was found, and 1 (one) if the key is not found ("section or key is invalid").
    #
    __t_tmp=$("${GIT_PROG}" config --global --get "${__t_key}")
    __t_estat=$?
    if test ${__t_estat} -ne 0 \
    && test ${__t_estat} -ne 1; then
        printf "${PROG} (error): was unable to query git config (scope: \"global\") for key: \"%s\"; bailing out\n" "${__t_key}" 1>&2
        exit 1
    fi

    if test ${__t_estat} -eq 0; then
        if $DEBUGGING; then
            printf "${PROG} (debug): found git config key \"%s\" in scope \"global\"\n" "${__t_key}" 1>&2
        fi
    else
        if $DEBUGGING; then
            printf "${PROG} (debug): checking git config (scope: \"system\") for key: \"%s\"\n" "${__t_key}" 1>&2
        fi
        __t_tmp=$("${GIT_PROG}" config --system --get "${__t_key}")
        __t_estat=$?
        if test ${__t_estat} -ne 0 \
        && test ${__t_estat} -ne 1; then
            printf "${PROG} (error): was unable to query git config (scope: \"system\") for key: \"%s\"; bailing out\n" "${__t_key}" 1>&2
            exit 1
        fi
        if test ${__t_estat} -ne 0; then
            return 1  # key not found in either "global" or "system" scope
        fi
        if $DEBUGGING; then
            printf "${PROG} (debug): found git config key \"%s\" in scope \"system\"\n" "${__t_key}" 1>&2
        fi
    fi

    printf -v "${__t_var}" '%s' "${__t_tmp}"
    if test $? -ne 0; then
        printf "${PROG} (error): ${FUNCNAME}(): was unable to write value to global var \"%s\"; bailing out\n" "${__t_var}" 1>&2
        exit 1
    fi

    return 0  # success
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['default-branch']=1    # -b (--default-branch=NAME)
    ['description']=1       # -d (--description=BLURB)
    ['force-replace']=0     #    (--force-replace)
    ['homepage']=1          #    (--homepage=URL)

    ['disable-issues']=0    # -I (--disable-issues)
    ['disable-projects']=0  # -P (--disable-projects)
    ['disable-wiki']=0      # -W (--disable-wiki)

    ['output-format']=1     # -O (--output-format)

    ['private']=0   # -p (--private)
    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVb:d:IO:PpvW' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

                # All of our command line options that accept arguments
                # require the values for those arguments to be non-empty
                # strings.
                if [[ "${OPTARG}" =~ $RE_BLANK ]]; then
                    printf "${PROG} (error): argument for option '--%s' may not be blank; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option --${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND

                    # All of our command line options that accept arguments
                    # require the values for those arguments to be non-empty
                    # strings.
                    if [[ "${OPTARG}" =~ $RE_BLANK ]]; then
                        printf "${PROG} (error): argument for option '--%s' may not be blank; bailing out\n" "${opt}" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;

            'default-branch' | 'b')
                f_set_opt_default_branch_name_or_die "${OPTARG}"
                ;;

            'description' | 'd')
                f_set_opt_new_repo_desc_or_die "${OPTARG}"
                ;;

            'disable-issues' | 'I')
                FLG_NEW_REPO_ISSUES_ENABLED=false
                ;;

            'disable-projects' | 'P')
                FLG_NEW_REPO_PROJECTS_ENABLED=false
                ;;

            'disable-wiki' | 'W')
                FLG_NEW_REPO_WIKI_ENABLED=false
                ;;

            'force-replace')  # XXX: dangerous op
                DO_FORCE_REPLACE=true
                ;;

            'homepage')
                # Design note: There is no short form for this option. Two
                # natural choices might seem to be '-h' and '-H', but we do
                # not want to use either of those for this purpose.
                #
                #     * '-h' is already used as the short form for '--help',
                #       and from a usability perspective that use case is far
                #       more important for this one.
                #
                #     * '-H' might make sense in some other program, but here
                #       we are using capital letters for the short-form
                #       "--disable-FOO" options (see '-I', '-P', and '-W'),
                #       and specifying a home page does not fit into that
                #       scheme.
                #
                f_set_opt_new_repo_url_homepage_or_die "${OPTARG}"
                ;;

            'output-format' | 'O' )
                t_local_opt_string='-'"${opt}"  # correct for single-letter option name
                if test "${#opt}" -gt 1; then
                    t_local_opt_string='-'"${t_local_opt_string}"  # correct for long-form option name
                fi
                f_set_output_format_or_die "${t_local_opt_string}" "${OPTARG}"
                ;;

            'private' | 'p')
                FLG_NEW_REPO_IS_PUBLIC=false
                ;;

            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;


            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;
        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# sanity check
if $HAVE_NEW_REPO_NAME; then
    printf "${PROG} (BUG): new repo name set prematurely? (%s); bailing out\n" "${NEW_REPO_NAME}" 1>&2
    exit 1
fi
# The first non-option command argument is interpretted as the name of the new
# repository to create.
if test $# -lt 1; then
    printf "${PROG} (error): REPO_NAME not provided; bailing out\n" 1>&2
    f_print_help 1>&2
    exit 1
fi

f_set_opt_new_repo_name_or_die "$1"
shift

if test $# -gt 0; then
    printf "${PROG} (error): only one REPO_NAME may be specified; bailing out\n" 1>&2
    f_print_help 1>&2
    exit 1
fi


if test -z "${OUTPUT_FORMAT}"; then
    OUTPUT_FORMAT=$DFLT_OUTPUT_FORMAT
fi


if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then :; else
    # The user did not specify on the command line a default branch name to
    # use, but (since git 2.28 (tagged as such on 2020-07-26)) a preference
    # may be available in the user's ~/.gitconfig file under the key:
    #
    #     init.defaultBranch
    #
    # We will honor that setting, if it exists. If the setting does not exist,
    # then the default branch name will be whatever the GitHub API uses by
    # default. Prior to 2020-10-01, that value was 'master'. After 2020-10-01,
    # the value is 'main'.
    #
    # See also:
    #     * git-config(1) -- the entry for 'init.defaultBranch' (git >= 2.28)
    #
    #     * https://github.blog/2020-07-27-highlights-from-git-2-28/#introducing-init-defaultbranch
    #
    #     * https://github.blog/changelog/2020-08-26-set-the-default-branch-for-newly-created-repositories/
    #     * https://github.com/github/renaming
    #
    if $DEBUGGING; then
        printf "${PROG} (debug): no default branch specified on command line; will check git config for 'init.defaultBranch'\n" 1>&2
    fi

    declare t_key_name='init.defaultBranch'
    declare t_global_out_val
    f_get_git_config_opt_ignoring_local_repo "${t_key_name}" 't_global_out_val'

    if test $? -eq 1; then
        if $DEBUGGING; then
            printf "${PROG} (debug): did not find a git config value for key '%s' (okay)\n" "${t_key_name}" 1>&2
        fi
    else
        if test -z "${t_global_out_val}"; then
            printf "${PROG} (warning): found empty value for git config key '%s'; ignoring\n" "${t_key_name}" 1>&2
        elif [[ "${t_global_out_val}" =~ $RE_BLANK ]]; then
            printf "${PROG} (warning): found blank value for git config key '%s'; ignoring\n" "${t_key_name}" 1>&2
        else
            if $DEBUGGING; then
                printf "${PROG} (debug): found a git config value for key '%s': \"%s\"\n" "${t_key_name}" "${t_global_out_val}" 1>&2
            fi
            NEW_REPO_DFLT_BRANCH_NAME=${t_global_out_val}
            HAVE_NEW_REPO_DFLT_BRANCH_NAME=true
        fi
    fi
    unset t_global_out_val
fi

:
: Key flags and options summary:
: ------------------------------
: "$PROG (trace: $LINENO): force-replace enabled?: ${DO_FORCE_REPLACE}"
:
: "$PROG (trace: $LINENO):          output format: ${OUTPUT_FORMAT}"
:
: "$PROG (trace: $LINENO):     have new repo name: ${HAVE_NEW_REPO_NAME}"
: "$PROG (trace: $LINENO):    new repo name value: \"${NEW_REPO_NAME}\""
:
: "$PROG (trace: $LINENO):  have dflt branch name: ${HAVE_NEW_REPO_DFLT_BRANCH_NAME}"
: "$PROG (trace: $LINENO): dflt branch name value: \"${NEW_REPO_DFLT_BRANCH_NAME}\""
:
: "$PROG (trace: $LINENO):     have new repo desc: ${HAVE_NEW_REPO_DESC}"
: "$PROG (trace: $LINENO):    new repo desc value: \"${NEW_REPO_DESC}\""
:
: "$PROG (trace: $LINENO):  have new repo url homepage: ${HAVE_NEW_REPO_URL_HOMEPAGE}"
: "$PROG (trace: $LINENO): new repo url homepage value: \"${NEW_REPO_URL_HOMEPAGE}\""
:
: "$PROG (trace: $LINENO):   issues enabled?: ${FLG_NEW_REPO_ISSUES_ENABLED}"
: "$PROG (trace: $LINENO): projects enabled?: ${FLG_NEW_REPO_PROJECTS_ENABLED}"
: "$PROG (trace: $LINENO):     wiki enabled?: ${FLG_NEW_REPO_WIKI_ENABLED}"
:
: "$PROG (trace: $LINENO):   repo is public?: ${FLG_NEW_REPO_IS_PUBLIC}"


MY_TMP_DIR=$("${MKTEMP_PROG}" -t --directory "${PROG}.XXXXXXXX")
if test $? -ne 0; then
    printf "${PROG} (error) was unable to create temporary directory; bailing out\n" 1>&2
    exit 1
fi
#
# This should be a "can't happen" scenario, but since we do a 'rm -fr ...' on
# the value when we are done, we want to be belt-and-suspenders about it...
#
if test -z "${MY_TMP_DIR}"; then
    printf "${PROG} (error) temporary directory path is empty; bailing out\n" 1>&2
    exit 1
fi
function f_cleanup_rmfr_tmpdir () {
    local -a t_rm_opts=()
    t_rm_opts+=('-f')
    t_rm_opts+=('-r')
    if $TRACING; then
        t_rm_opts+=('-v')  # verbose
    fi
    "${RM_PROG}" "${t_rm_opts[@]}" "${MY_TMP_DIR}"
    # Ignore exit status -- Is a cleanup hook, so do not exit the process if
    # 'rm' failed; keep going...
}
F_CLEANUP_HOOK_NAMES+=( 'f_cleanup_rmfr_tmpdir' )

declare -r MY_TMP_CURL_OUT_FPATH="${MY_TMP_DIR}/curl.out"
declare -r MY_TMP_GIT_REPO_FPATH="${MY_TMP_DIR}/repo.git"

# Obtain the username (a.k.a. "owner" or "login") of the authenticated GitHub
# user.
GITHUB_REPO_OWNER=$("${AGH_WHOAMI_PROG}")
if test $? -ne 0; then
    printf "${PROG} (error): was unable to obtain the name of the authenticated GitHub user; bailing out\n" 1>&2
    exit 1
fi
if test -z "${GITHUB_REPO_OWNER}"; then
    printf "${PROG} (error): empty value obtained for name of the authenticated GitHub user; bailing out\n" 1>&2
    exit 1
fi
declare -r GITHUB_REPO_OWNER
if $BE_VERBOSE; then
    printf "${PROG} (info): GitHub repo owner is: %s\n" "${GITHUB_REPO_OWNER}" 1>&2
fi


# Create URL-encoded variations of our GITHUB_REPO_OWNER and NEW_REPO_NAME,
# both of which appear in URLs used for the GitHub v3 API.
#
declare    GITHUB_REPO_OWNER_URLENC
declare    NEW_REPO_NAME_URLENC
f_url_encode "${GITHUB_REPO_OWNER}" 'GITHUB_REPO_OWNER_URLENC'
f_url_encode "${NEW_REPO_NAME}"     'NEW_REPO_NAME_URLENC'
declare -r GITHUB_REPO_OWNER_URLENC
declare -r NEW_REPO_NAME_URLENC


# Build up our repository request JSON structure based on the configuration
# bits specified by the user and/or gathered from contextual info.
#
# The only key that is a required param by the GitHub API is 'name'.
#
# For non-boolean fields, we only specify a key/value pair if we have have
# gathered a value.
#
# Note that we have 'auto_init' set to true to cause an initial commit to be
# made with an empty README.md file. We need to have at least one commit to
# reify the default branch; otherwise we will not be able to rename it below
# (git only makes the branch real upon the first commit).
#
# XXX: Note that we /always/ have the 'auto_init' flag set to true. Strictly
#      speaking it is only needed when the user has specified a default branch
#      name that is different from that used by the GitHub API (since
#      2020-10-01, that value is "main"). It is not yet clear whether this
#      will prove to be an annoyance. For the time being, we are opting for
#      consistency of behavior; users should not have to keep fidly little
#      details like this in mind to use the tool.
#
# FIXME: Consider supporting 'visibility' (public|private|internal).
#
#        - Would override the 'private' (true|false) param, if both were
#          provided.
#
#        - Would require using the 'nebula-preview' header:
#          Access: application/vnd.github.nebula-preview+json
#
json_create=$("${CAT_PROG}" - <<EOF
{
    "auto_init": "true",
    "name":      "${NEW_REPO_NAME}"
EOF
)

# XXX: Empirical testing against the GitHub v3 API revealed some wonkiness: if
#      you explicitly specify 'private:false', then the repo is created as
#      'private:true'.
#
#      But if you simply omit the 'private' key when you do not want a private
#      repo, then the repo is created as 'private:false'.
#
if $FLG_NEW_REPO_IS_PUBLIC; then :;
#    json_create="${json_create}, \"private\": \"false\""
else
    json_create="${json_create}, \"private\": \"true\""
fi

if $FLG_NEW_REPO_ISSUES_ENABLED; then
    json_create="${json_create}, \"has_issues\": \"true\""
else
    json_create="${json_create}, \"has_issues\": \"false\""
fi

# XXX: Empirical testing against the GitHub v3 API revealed some wonkiness: if
#      you explicitly specify 'has_projects:false', then the repo is created
#      as 'has_projects:true'.
#
#      Unlike the 'private' field above, there's not easy workaround for this
#      one other than checking what we get back later on and PATCHing the repo
#      with an update to achieve the desired end state.
#
if $FLG_NEW_REPO_PROJECTS_ENABLED; then
    json_create="${json_create}, \"has_projects\": \"true\""
else
    json_create="${json_create}, \"has_projects\": \"false\""
fi

if $FLG_NEW_REPO_WIKI_ENABLED; then
    json_create="${json_create}, \"has_wiki\": \"true\""
else
    json_create="${json_create}, \"has_wiki\": \"false\""
fi

if $HAVE_NEW_REPO_DESC; then
    json_create="${json_create}, \"description\": \"${NEW_REPO_DESC}\""
fi

if $HAVE_NEW_REPO_URL_HOMEPAGE; then
    json_create="${json_create}, \"homepage\": \"${NEW_REPO_URL_HOMEPAGE}\""
fi

# Writing in 2020-10, this one is not (yet?) honored by the repo creation API
# endpoint (but we have a workaround; see below).
if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then
    json_create="${json_create}, \"default_branch\": \"${NEW_REPO_DFLT_BRANCH_NAME}\""
fi

json_create="${json_create}"' }'  # close JSON object


: $PROG \(trace: $LINENO\): json_create: @@@[[[___"${json_create}"___]]]@@@


# XXX: At the time of writing (2020-10-04), the 'default_branch' param in the
#      above is ignored by the GitHub API at the time of repo creation, even
#      though a 'default_branch' key is returned in the response. The value of
#      the key in the response does not reflect the value we provided, so the
#      code below jumps through hoops to rename the branch locally, and then
#      synchronize the remote repo with the same changes.


# Common global options for use in every 'curl' invocation. Specific
# invocations will require additional options, but such usages should not
# modify this array.
#
declare -a MY_CURL_DEFAULT_OPTS=()
declare -a MY_CURL_OPTS=()

# This disables output of curl's progress meter /and/ output of error messages...
MY_CURL_DEFAULT_OPTS+=( '--silent' )
# ...but this re-enables output of the error messages.
MY_CURL_DEFAULT_OPTS+=( '--show-error' )


# Force use of TLS 1.2 (or later). Writing in 2016, all previous versions are
# known to be broken and susceptible to known attacks. Note that the
# '--tlsv1.2' option was added in curl 7.34.0
#
# This is absolutely essential since we're using HTTP Basic Auth (see below).
#
MY_CURL_DEFAULT_OPTS+=( '--tlsv1.2' )

# Allow ONLY https, for both the initial request and for redirects
MY_CURL_DEFAULT_OPTS+=( '--proto')
MY_CURL_DEFAULT_OPTS+=( 'https')
MY_CURL_DEFAULT_OPTS+=( '--proto-redir')
MY_CURL_DEFAULT_OPTS+=( 'https')


# Tell curl to use HTTP Basic Authentication. This is the curl default, but
# we're explicit about what we expect (and want to avoid any surprises from
# weirdo ~/.curlrc files).
#
# See also: RFC 7617 "The 'Basic' HTTP Authentication Scheme" (2015-09)
#
MY_CURL_DEFAULT_OPTS+=( '--basic' )


# User's authentication credentials will be obtained from the user's ~/.netrc
# file. See curl(1) and netrc(5)
#
MY_CURL_DEFAULT_OPTS+=( '--netrc'  )

MY_CURL_DEFAULT_OPTS+=( '--user-agent' )
MY_CURL_DEFAULT_OPTS+=( "$PROG"        )


# Even when we're just making HEAD requests, have curl fail
# MY_CURL_DEFAULT_OPTS+=( '--fail' )


# Tell the GitHub service that we're trying to speak v3 of the API. Writing in
# 2020, v3 is the default, but there is also a 'GraphQL API v4' version which
# we do not use here. Some newer version may become the default in the future,
# so we are explicit about which version we are using.
#
MY_CURL_DEFAULT_OPTS+=( '--header' )
MY_CURL_DEFAULT_OPTS+=( "${gl_const_http_accept_github_version}" )

# We always write the (JSON) output to a file in our temporary directory...
#
MY_CURL_DEFAULT_OPTS+=( '--output' )
MY_CURL_DEFAULT_OPTS+=( "${MY_TMP_CURL_OUT_FPATH}" )

# ...and write the HTTP response status to stdout. This allows for robust
# error handling. Also, we cannot really know how to interpret the output
# returned from the remote server until we have examined (at least) the HTTP
# response code.
#
MY_CURL_DEFAULT_OPTS+=( '--write-out'  )
MY_CURL_DEFAULT_OPTS+=( '%{http_code}' )


MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

MY_CURL_OPTS+=( '--get' )

# First check to see if the repo already exists. API responds with HTTP 200 on
# success (meaning repo was found to exist). The output (in our temporary
# 'curl.out' file) will be GitHub's JSON representation of the repository.
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}")
t_estat=$?

if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to retrieve existing repo; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

REPO_EXISTS=
NEED_TO_DELETE_EXISTING=false
case ${t_http_code} in

    '200')
        REPO_EXISTS=true

        if $DO_FORCE_REPLACE; then
            NEED_TO_DELETE_EXISTING=true
        else
            printf "${PROG} (error): GitHub repository already exists: %s/%s; will not delete\n    Use '--force-replace' to override\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            exit 1
        fi
        ;;

    '404')
        REPO_EXISTS=false
        # Keep going...
        ;;

    *)
        printf "${PROG} (error): HTTP response code was: \"%s\"; expected 200 (\"OK\"); bailing out\n" \
               "${t_http_code}" 1>&2
        exit 1
        ;;
esac

if ! ${REPO_EXISTS}; then

    if $BE_VERBOSE; then

        if ${DO_FORCE_REPLACE}; then
            # User explicitly requested that an existing repo be deleted, but
            # no existing repo was found. We'll emit a slightly different
            # message customized to this circumstance.
            #
            printf "${PROG} (info): deletion of existing GitHup repo requested, but repo does not exist: %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
        else
            printf "${PROG} (info): GitHub repository does not yet exist: %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
        fi
    fi
else
    # Repo exists, and the user wants us to delete it

    # Internal sanity checks
    if ${DO_FORCE_REPLACE}; then :; else
        printf "${PROG} (BUG): [line: ${LINENO}] DO_FORCE_REPLACE should be set here; bailing out\n" 1>&2
        exit 1
    fi
    if ${NEED_TO_DELETE_EXISTING}; then :; else
        printf "${PROG} (BUG): [line: ${LINENO}] NEED_TO_DELETE_EXISTING should be set here; bailing out\n" 1>&2
        exit 1
    fi

    if $BE_VERBOSE; then
        printf "${PROG} (info): as requested, will delete existing GitHup repo: %s/%s\n" \
               "${GITHUB_REPO_OWNER}" \
               "${NEW_REPO_NAME}" 1>&2
    fi

    MY_CURL_OPTS=()  # (re)set
    MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

    MY_CURL_OPTS+=( '--request' )  # -X
    MY_CURL_OPTS+=( 'DELETE' )

    # DELETE /repos/:owner/:repo
    #
    # Upon success, we will expect an HTTP 204 ("No Content") reponse.
    #
    # Possible expected errors include:
    #
    #
    #     404 ("Not Found") - If the repo does not exist. Though we checked
    #                         for the existence of the repo above, it would
    #                         still be possible for some other process to have
    #                         come along and deleted the repo since we
    #                         checked.
    #
    #     403 ("Forbidden") - If an organization owner has configured the
    #                         organization to prevent members from deleting
    #                         organization owned repos
    #
    # https://developer.github.com/v3/repos/#delete-a-repository
    # https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#delete-a-repository
    #
    t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                                 "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}" )
    t_estat=$?

    if test $t_estat -ne 0; then
        printf "${PROG} (error): was error while invoking curl(1) to DELETE existing repo; bailing out\n" 1>&2
        exit 1
    fi
    if test -z "${t_http_code}"; then
        printf "${PROG} (error): curl(1) DELETE command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
        exit 1
    fi

    case ${t_http_code} in

        '204')
            if $BE_VERBOSE; then
                printf "${PROG} (info): successfully deleted existing GitHup repo: %s/%s\n" \
                       "${GITHUB_REPO_OWNER}" \
                       "${NEW_REPO_NAME}" 1>&2
            fi
            ;;

        '403')
            printf "${PROG} (error): curl(1) DELETE resulted in a 403 (\"Forbidden\"); was unable to delete repo: %s/%s; bailing out\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            exit 1
            ;;

        '404')
            # This should only happen if some other process is attempting to
            # delete the repo at the same time we are, and that other process
            # beat us to it. Highly unlikely, except in contrived situations.
            #
            printf "${PROG} (warning): curl(1) DELETE resulted in a 404 (\"Not Found\"); existing GitHup repo deleted by some other means (not us): %s/%s\n" \
                   "${GITHUB_REPO_OWNER}" \
                   "${NEW_REPO_NAME}" 1>&2
            # keep going...
            ;;

        *)
          printf "${PROG} (error): HTTP response code for DELETE command was: \"%s\"; expected 204 (\"No Content\"); bailing out\n" \
                 "${t_http_code}" 1>&2
          exit 1
          ;;
    esac
fi

MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

# Recall that the '--data' option implies an HTTP POST request.
#
MY_CURL_OPTS+=( '--data' )
MY_CURL_OPTS+=( "${json_create}" )

if $BE_VERBOSE; then
    printf "${PROG} (info): attempting to create new GitHup repo: %s/%s\n" \
           "${GITHUB_REPO_OWNER}" \
           "${NEW_REPO_NAME}" 1>&2
fi

# Create a new repository for the authenticated user. Note that that the
# literal string token 'user' in 'user/repos' is correct (it IS NOT supposed
# to be the name of the authenticated user; that is implied by the
# credentials)
#
# We are expecting an HTTP 201 if the new repository was successfully
# created. We'll treat any other response code as an error.
#
# If the repository already exists (and possibly other scenarios), the HTTP
# response code will be 422 ("Unprocessable Entity") [RFC 4918].
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}user/repos")
t_estat=$?
if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to create repo; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

if test '201' = "${t_http_code}"; then
    if $BE_VERBOSE; then
        printf "${PROG} (info): successfully created new GitHup repo: %s/%s\n" \
               "${GITHUB_REPO_OWNER}" \
               "${NEW_REPO_NAME}" 1>&2
    fi
else
    printf "${PROG} (error): HTTP response code was: \"%s\"; expected 201 (\"Created\"); bailing out\n" \
           "${t_http_code}" 1>&2
    exit 1
fi

if test -s "${MY_TMP_CURL_OUT_FPATH}"; then :; else
    printf "${PROG} (error): repo created, but JSON response not available; bailing out\n" 1>&2
    exit 1
fi


# XXX: Consider checking /every/ field from the response for deviations from
#      what was requested. Currently we check only the most critical bits.

read -r is_private is_fork dflt_branch_name \
  < <("${JQ_PROG}" -r '"\(.private) \(.fork) \(.default_branch)"' < "${MY_TMP_CURL_OUT_FPATH}")
if test $? -ne 0; then
    # Hopefully some other (more useful) error message was also emitted by
    # jq(1) or bash(1)...
    printf "${PROG} (error): was unable to extract data from JSON response; bailing out\n" 1>&2
    exit 1
fi

if [[ "${is_private}" =~ $RE_JSON_BOOLEAN ]]; then :; else
    printf "${PROG} (error): unrecognized value obtained for 'is_private': \"%s\"; bailing out\n" "${is_private}" 1>&2
    exit 1
fi
if [[ "${is_fork}" =~ $RE_JSON_BOOLEAN ]]; then :; else
    printf "${PROG} (error): unrecognized value obtained for 'is_fork': \"%s\"; bailing out\n" "${is_fork}" 1>&2
    exit 1
fi


# Sanity check: We just created the repo directly, so it should not look like
# a GitHub fork.
if test "${is_fork}" = 'false'; then :; else
    printf "${PROG} (error): 'is_fork' attribute on newly create repo expected to be 'true', but is: %s; bailing out\n" \
           "${is_fork}" 1>&2
    exit 1
fi

# Sanity check: Verify that the visibility of the repository reflects what we
# requested it to be.
if ${FLG_NEW_REPO_IS_PUBLIC}; then
    if test "${is_private}" = 'false'; then :; else
        printf "${PROG} (error): 'is_private' attribute on newly create repo expected to be 'false', but is: %s; bailing out\n" \
               "${is_private}" 1>&2
        exit 1
    fi
else
    if test "${is_private}" = 'true'; then :; else
        printf "${PROG} (error): 'is_private' attribute on newly create repo expected to be 'true', but is: %s; bailing out\n" \
               "${is_private}" 1>&2
        exit 1
    fi
fi


# Writing in 2020-10, we expect that our request for any particular default
# branch name was ignored by the GitHub v3 API. We only verify it, though, if:
#
#     a) a specific value was requested; and
#     b) that specific value is something different from the GitHub default ("main")
#
if $HAVE_NEW_REPO_DFLT_BRANCH_NAME; then

    if test 'main' = "${NEW_REPO_DFLT_BRANCH_NAME}"; then :; else

        if test "${dflt_branch_name}" = "${NEW_REPO_DFLT_BRANCH_NAME}"; then

            # AUTHOR NOTE (2020-10-04): If somebody encounters this scenario in the
            # wild before the author does, please open an issue on GitHub to let him
            # know about it. It would indicate a (probably good) change in the
            # behavior of the GitHub API that this program should be adapted to
            # interpret more accurately.
            #
            #     https://github.com/salewski/ads-github-tools/issues
            #
            printf "${PROG} (warning): unexpected success: GitHub API honored our initial 'default_branch' request\n" 1>&2
            # Keep going...
        else
            if $BE_VERBOSE; then
                printf "${PROG} (info): specific default branch name specified; doing clone/rename dance\n" 1>&2
            fi

            # Since our requested default branch name was ignored, we'll check out the
            # repo, rename it locally, and then sync that state to the remote repo.

            if $BE_VERBOSE; then
                printf "${PROG} (info): [local repo] clone newly created repo..." 1>&2
            fi
            "${GIT_PROG}" clone --quiet 'git@github.com:'"${GITHUB_REPO_OWNER}/${NEW_REPO_NAME}.git" "${MY_TMP_GIT_REPO_FPATH}"
            if test $? -ne 0; then
                $BE_VERBOSE && printf '\n' 1>&2
                printf "${PROG} (error): was unable while trying to clone newly created repo; bailing out\n" 1>&2
                exit 1
            fi
            if $BE_VERBOSE; then
                printf '.done.\n' 1>&2
            fi

            (
              cd "${MY_TMP_GIT_REPO_FPATH}"
              if test $? -ne 0; then
                  printf "${PROG} (error): was unable to cd to directory of newly created repo; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi

              # We are currently on the default branch. Let's rename it it.
              #
              if $BE_VERBOSE; then
                  printf "${PROG} (info): [local repo] on default branch; renaming it..." 1>&2
              fi
              "${GIT_PROG}" branch --move "${dflt_branch_name}" "${NEW_REPO_DFLT_BRANCH_NAME}"
              if test $? -ne 0; then
                  $BE_VERBOSE && printf '\n' 1>&2
                  printf "${PROG} (error): was unable to rename branch locally; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if $BE_VERBOSE; then
                  printf '.done.\n' 1>&2
              fi


              # Let the repo represented by our 'origin' remote know that there's a new branch
              if $BE_VERBOSE; then
                  printf "${PROG} (info): [local repo] pushing renamed branch to origin..." 1>&2
              fi
              # We jump through hoops to suppress 'remote:' messages without
              # suppresssing legit stderr messages.
#              "${GIT_PROG}" push --quiet --set-upstream origin "${NEW_REPO_DFLT_BRANCH_NAME}"
              "${GIT_PROG}" push --quiet origin "${NEW_REPO_DFLT_BRANCH_NAME}" \
                  2> >( re_rmt='^remote:';
                        while read -r line; do
                            if [[ "${line}" =~ $re_rmt ]]; then :; else
                                printf '%s\n' "${line}" 1>&2
                            fi
                        done ) \
                  1> /dev/null
              if test $? -ne 0; then
                  $BE_VERBOSE && printf '\n' 1>&2
                  printf "${PROG} (error): was unable to push new branch to origin; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if $BE_VERBOSE; then
                  printf '.done.\n' 1>&2
              fi


              # Now that the remote side knows about our new branch, our
              # 'origin' remote should have a reference for the branch. Let's
              # make that one the branch being tracked from our current local
              # branch.
              #
              # Yes, we could have done this above with a '--set-upstream'
              # option in our git-push(1) call, but then we could not control
              # the program output as well (the '--quiet' would not be enough
              # to silence some of the unwanted output).
              #
              if $BE_VERBOSE; then
                  printf "${PROG} (info): [local repo] track new branch from upstream..." 1>&2
              fi
              "${GIT_PROG}" branch --quiet --set-upstream-to "origin/${NEW_REPO_DFLT_BRANCH_NAME}"
              if test $? -ne 0; then
                  $BE_VERBOSE && printf '\n' 1>&2
                  printf "${PROG} (error): was unable to set upstream to new branch in origin remote; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if $BE_VERBOSE; then
                  printf '.done.\n' 1>&2
              fi


              # locally: Switch our default branch
              if $BE_VERBOSE; then
                  printf "${PROG} (info): [local repo] pointing HEAD to %s..." "${NEW_REPO_DFLT_BRANCH_NAME}" 1>&2
              fi
              "${GIT_PROG}" remote set-head origin "${NEW_REPO_DFLT_BRANCH_NAME}"
              if test $? -ne 0; then
                  $BE_VERBOSE && printf '\n' 1>&2
                  printf "${PROG} (error): was unable to switch default branch locally; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if $BE_VERBOSE; then
                  printf '.done.\n' 1>&2
              fi


              # Note that our local repo will still have a remote ref for the original
              # repo branch until we tell the remote to delete it below.

              # remotely: Change the default branch for the repo
              json_patch_dflt_name=$("${CAT_PROG}" - <<EOF
{
    "default_branch": "${NEW_REPO_DFLT_BRANCH_NAME}"
}
EOF
                                    )

              MY_CURL_OPTS=()  # (re)set
              MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

              MY_CURL_OPTS+=( '--data' )  # implies POST (overridden below)
              MY_CURL_OPTS+=( "${json_patch_dflt_name}" )

              MY_CURL_OPTS+=( '--request' )  # -X
              MY_CURL_OPTS+=( 'PATCH'     )  # override POST; use PATCH instead

              if $BE_VERBOSE; then
                  printf "${PROG} (info): remotely: attempting to PATCH dflt branch name for GitHup repo: %s/%s\n" \
                         "${GITHUB_REPO_OWNER}" \
                         "${NEW_REPO_NAME}" 1>&2
              fi

              # "Update a repository"
              #     https://developer.github.com/v3/repos/#update-a-repository
              #     https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#update-a-repository
              #
              # Known possible responses:
              #     200 OK
              #     403 Forbidden
              #     404 Not Found
              #     422 Unprocessable Entity
              #
              # On success, the returned JSON response should reflect the changes we
              # attempted to "PATCH in".
              #
              t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                                           "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER}/${NEW_REPO_NAME}")
              t_estat=$?
              if test $t_estat -ne 0; then
                  printf "${PROG} (error): was error while invoking curl(1) to PATCH existing repo; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if test -z "${t_http_code}"; then
                  printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted for PATCH; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi

              case ${t_http_code} in
                '200')  # "OK"
                    if $BE_VERBOSE; then
                        # CAREFUL: We'll note that the PATCH operation succeeded, but
                        #          don't want to suggest that the actual default
                        #          branch change succeeded until we confirm below by
                        #          reading the expected values back in the JSON
                        #          response we received.
                        printf "${PROG} (info): successfully PATCHed existing GitHup repo: %s/%s\n" \
                               "${GITHUB_REPO_OWNER}" \
                               "${NEW_REPO_NAME}" 1>&2
                    fi
                    ;;

                '403')
                    printf "${PROG} (error): curl(1) PATCH resulted in a 403 (\"Forbidden\"); was unable to patch repo: %s/%s; bailing out\n" \
                           "${GITHUB_REPO_OWNER}" \
                           "${NEW_REPO_NAME}" 1>&2
                    exit 1  # from subshell
                    ;;

                '404')
                    # This should only happen if some other process is attempting to
                    # modify the repo at the same time we are.
                    #
                    printf "${PROG} (error): curl(1) PATCH resulted in a 404 (\"Not Found\"); existing GitHup repo deleted by some other means (not us): %s/%s; bailing out\n" \
                           "${GITHUB_REPO_OWNER}" \
                           "${NEW_REPO_NAME}" 1>&2
                    exit 1  # from subshell
                    ;;

                '422')  # "Unprocessable Entity"
                    # This one is probably a bug in the current program related to not
                    # structuring our PATCH request correctly (including problems
                    # related to encoding the data correctly).
                    #
                    printf "${PROG} (error): curl(1) PATCH resulted in a 422 (\"Unprocessable Entity\"); was unable to patch repo: %s/%s; bailing out\n" \
                           "${GITHUB_REPO_OWNER}" \
                           "${NEW_REPO_NAME}" 1>&2
                    exit 1  # from subshell
                    ;;

                *)
                  printf "${PROG} (error): HTTP response code for PATCH command was: \"%s\"; expected 200 (\"OK\"); bailing out\n" \
                         "${t_http_code}" 1>&2
                  exit 1  # from subshell
                  ;;
              esac

              # Ensure the default_branch name in-use (as reflected in the JSON
              # response to our PATCH operation) actually reflects the name we
              # requested.
              read -r rsp_dflt_branch_name \
                   < <("${JQ_PROG}" -r '"\(.default_branch)"' < "${MY_TMP_CURL_OUT_FPATH}")
              if test $? -ne 0; then
                  # Hopefully some other (more useful) error message was also emitted
                  # by jq(1) or bash(1)...
                  printf "${PROG} (error): was unable to extract data from PATCH JSON response; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi

              if test "${rsp_dflt_branch_name}" = "${NEW_REPO_DFLT_BRANCH_NAME}"; then
                  if $BE_VERBOSE; then
                      printf "${PROG} (info): successfully changed default branch for existing GitHup repo: %s/%s\n" \
                             "${GITHUB_REPO_OWNER}" \
                             "${NEW_REPO_NAME}" 1>&2
                  fi
              else
                  if test "${rsp_dflt_branch_name}" = "${dflt_branch_name}"; then
                      printf "${PROG} (error): PATCH op to change default branch name succeeded, but request was ignored by the GitHub API; bailing out\n" 1>&2
                      exit 1  # from subshell
                  fi

                  printf "${PROG} (error): PATCH op to change default branch name succeeded, but new default branch name is unexpected value (\"%s\"); bailing out\n" \
                         "${rsp_dflt_branch_name}" 1>&2
                  exit 1  # from subshell
              fi

              # remotely: Delete old default branch from GitHub repo
              if $BE_VERBOSE; then
                  printf "${PROG} (info): [remote repo] delete old default branch from GitHub repo..." 1>&2
              fi
              "${GIT_PROG}" push --quiet origin --delete "${dflt_branch_name}"
              if test $? -ne 0; then
                  $BE_VERBOSE && printf '\n' 1>&2
                  printf "${PROG} (error): was unable to delete old default branch remotely; bailing out\n" 1>&2
                  exit 1  # from subshell
              fi
              if $BE_VERBOSE; then
                  printf '.done.\n' 1>&2
              fi

              if $BE_VERBOSE; then
                  printf "${PROG} (info): successfully changed default branch for GitHup repo: %s/%s\n" \
                         "${GITHUB_REPO_OWNER}" \
                         "${NEW_REPO_NAME}" 1>&2
              fi
              exit 0  # from subshell
            )
            if test $? -ne 0; then
                # Error message already printed in subshell
                exit 1
            fi
        fi
    fi
fi


# At this point, our newly (re)created repo exists. Let's retrieve the view of
# it and present a summary (or the raw JSON, if so requested) to the user.

MY_CURL_OPTS=()  # (re)set
MY_CURL_OPTS+=( "${MY_CURL_DEFAULT_OPTS[@]}" )  # copy

MY_CURL_OPTS+=( '--get' )

# The API responds with HTTP 200 on success (meaning repo was found to
# exist). The output (in our temporary 'curl.out' file) will be GitHub's JSON
# representation of the repository.
#
t_http_code=$("${CURL_PROG}" "${MY_CURL_OPTS[@]}" \
                             "${gl_const_github_api_base_url}repos/${GITHUB_REPO_OWNER_URLENC}/${NEW_REPO_NAME_URLENC}")
t_estat=$?

if test $t_estat -ne 0; then
    printf "${PROG} (error): was error while invoking curl(1) to retrieve repo for summary purposes; bailing out\n" 1>&2
    exit 1
fi
if test -z "${t_http_code}"; then
    printf "${PROG} (error): curl(1) command succeeded, but no HTTP response code emitted; bailing out\n" 1>&2
    exit 1
fi

case ${t_http_code} in

    '200')
        if $DEBUGGING; then
            printf "${PROG} (debug): successfully retrieved repo for summary purposes\n" 1>&2
        fi
        ;;

    '404')
        # Should only happen if some other process has come along and deleted
        # our new repo -- dueling banjos problem.
        printf "${PROG} (error): newly created repo does not exist(???); bailing out\n" 1>&2
        exit 1
        ;;

    *)
        printf "${PROG} (error): HTTP response code was: \"%s\"; expected 200 (\"OK\"); bailing out\n" \
               "${t_http_code}" 1>&2
        exit 1
        ;;
esac

if test "${OUTPUT_FORMAT}" = 'JSON'; then
    if test -s "${MY_TMP_CURL_OUT_FPATH}"; then :; else
        printf "${PROG} (error): JSON response is empty; bailing out\n" 1>&2
        exit 1
    fi

    "${CAT_PROG}" "${MY_TMP_CURL_OUT_FPATH}"
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to read JSON response from temporary file (\"%s\"); bailing out" \
               "${MY_TMP_CURL_OUT_FPATH}" 1>&2
        exit 1
    fi

    exit 0  # We're done
fi

if $DEBUGGING; then
    printf "${PROG} (debug): extracting fields from JSON response for summary purposes\n" 1>&2
fi

# NOTE: The 'description' field is read last because the value can contain
#       spaces; 'read' will clump them all into the last variable.
#
read -r  \
   ghr_name           \
   ghr_fork           \
\
   ghr_archived       \
   ghr_disabled       \
\
   ghr_created_at     \
   ghr_updated_at     \
\
   ghr_private        \
   ghr_visibility     \
\
   ghr_default_branch \
\
   ghr_has_issues     \
   ghr_has_projects   \
   ghr_has_wiki       \
\
   ghr_html_url       \
   ghr_homepage       \
   ghr_clone_url      \
   ghr_ssh_url        \
\
   ghr_owner_login    \
\
   ghr_description    \
  < <("${JQ_PROG}" -r ''\
'"\(if ((null == .name)           or ("" == .name))           then "-" else .name           end)'\
' \(if ((null == .fork)           or ("" == .fork))           then "-" else .fork           end)'\
\
' \(if ((null == .archived)       or ("" == .archived))       then "-" else .archived       end)'\
' \(if ((null == .disabled)       or ("" == .disabled))       then "-" else .disabled       end)'\
\
' \(if ((null == .created_at)     or ("" == .created_at))     then "-" else .created_at     end)'\
' \(if ((null == .updated_at)     or ("" == .updated_at))     then "-" else .updated_at     end)'\
\
' \(if ((null == .private)        or ("" == .private))        then "-" else .private        end)'\
' \(if ((null == .visibility)     or ("" == .visibility))     then "-" else .visibility     end)'\
\
' \(if ((null == .default_branch) or ("" == .default_branch)) then "-" else .default_branch end)'\
\
' \(if ((null == .has_issues)     or ("" == .has_issues))     then "-" else .has_issues     end)'\
' \(if ((null == .has_projects)   or ("" == .has_projects))   then "-" else .has_projects   end)'\
' \(if ((null == .has_wiki)       or ("" == .has_wiki))       then "-" else .has_wiki       end)'\
\
' \(if ((null == .html_url)       or ("" == .html_url))       then "-" else .html_url       end)'\
' \(if ((null == .homepage)       or ("" == .homepage))       then "-" else .homepage       end)'\
' \(if ((null == .clone_url)      or ("" == .clone_url))      then "-" else .clone_url      end)'\
' \(if ((null == .ssh_url)        or ("" == .ssh_url))        then "-" else .ssh_url        end)'\
\
' \(if ((null == .owner) or (null == .owner.login) or ("" == .owner.login)) then "-" else .owner.login end)'\
\
' \(if ((null == .description)    or ("" == .description))    then "-" else .description    end)'\
'"' < "${MY_TMP_CURL_OUT_FPATH}")
if test $? -ne 0; then
    # Hopefully some other (more useful) error message was also emitted by
    # jq(1) or bash(1)...
    printf "${PROG} (error): was unable to extract repo data from JSON response; bailing out\n" 1>&2
    exit 1
fi

:
: Extracted values from newly created repo:
: -----------------------------------------
: "$PROG (trace: $LINENO): ghr_name: ${ghr_name}"
: "$PROG (trace: $LINENO): ghr_fork: ${ghr_fork}"
:
: "$PROG (trace: $LINENO): ghr_archived: ${ghr_archived}"
: "$PROG (trace: $LINENO): ghr_disabled: ${ghr_disabled}"
:
: "$PROG (trace: $LINENO): ghr_created_at: ${ghr_created_at}"
: "$PROG (trace: $LINENO): ghr_updated_at: ${ghr_updated_at}"
:
: "$PROG (trace: $LINENO):    ghr_private: ${ghr_private}"
: "$PROG (trace: $LINENO): ghr_visibility: ${ghr_visibility}"
:
: "$PROG (trace: $LINENO): ghr_default_branch: ${ghr_default_branch}"
:
: "$PROG (trace: $LINENO):   ghr_has_issues: ${ghr_has_issues}"
: "$PROG (trace: $LINENO): ghr_has_projects: ${ghr_has_projects}"
: "$PROG (trace: $LINENO):     ghr_has_wiki: ${ghr_has_wiki}"
:
: "$PROG (trace: $LINENO):  ghr_html_url: ${ghr_html_url}"
: "$PROG (trace: $LINENO):  ghr_homepage: ${ghr_homepage}"
: "$PROG (trace: $LINENO): ghr_clone_url: ${ghr_clone_url}"
: "$PROG (trace: $LINENO):   ghr_ssh_url: ${ghr_ssh_url}"
:
: "$PROG (trace: $LINENO): ghr_owner_login: ${ghr_owner_login}"
:
: "$PROG (trace: $LINENO): ghr_description: ${ghr_description}"

if $DEBUGGING; then
    printf "${PROG} (debug): successfully extracted fields from JSON response; emitting summary\n" 1>&2
fi

if $ghr_fork; then
    ghr_fork_disp='yes' # should never be the case
else
    ghr_fork_disp='no'
fi

if $ghr_archived; then
    ghr_archived_disp='yes'
else
    ghr_archived_disp='no'
fi

if $ghr_disabled; then
    ghr_disabled_disp='yes'
else
    ghr_disabled_disp='no'
fi

if $ghr_private; then
    ghr_private_disp='yes'
else
    ghr_private_disp='no'
fi

if $ghr_has_issues; then
    ghr_has_issues_disp='yes'
else
    ghr_has_issues_disp='no'
fi

# FIXME: This setting is known to "not take"; may try harder via a follow-up PATCH operation?
if $ghr_has_projects; then
    ghr_has_projects_disp='yes'
else
    ghr_has_projects_disp='no'
fi

if $ghr_has_wiki; then
    ghr_has_wiki_disp='yes'
else
    ghr_has_wiki_disp='no'
fi

if test '-' = "${ghr_created_at}"; then
    ghr_created_at_disp=${ghr_created_at}
else
    ghr_created_at_disp=$("${DATE_PROG}" --utc --date="${ghr_created_at}" '+%F %T%z')
    if test $? -ne 0; then
        printf "${PROG} (warning): was unable to format raw \"created at\" date; will show raw value\n" 1>&2
        ghr_created_at_disp=${ghr_created_at}
        # keep going
    fi
fi

if test '-' = "${ghr_updated_at}"; then
    ghr_updated_at_disp=${ghr_updated_at}
else
    ghr_updated_at_disp=$("${DATE_PROG}" --utc --date="${ghr_updated_at}" '+%F %T%z')
    if test $? -ne 0; then
        printf "${PROG} (warning): was unable to format raw \"updated at\" date; will show raw value\n" 1>&2
        ghr_updated_at_disp=${ghr_updated_at}
        # keep going
    fi
fi


"${CAT_PROG}" - <<EOF
Summary of newly created repository:

            Name: ${ghr_name}
        Is fork?: ${ghr_fork_disp}
           Owner: ${ghr_owner_login}

    Is archived?: ${ghr_archived_disp}
    Is disabled?: ${ghr_disabled_disp}

      Created at: ${ghr_created_at_disp}
      Updated at: ${ghr_updated_at_disp}

     Is private?: ${ghr_private_disp}
      Visibility: ${ghr_visibility}

  Default branch: ${ghr_default_branch}

     Has issues?: ${ghr_has_issues_disp}
   Has projects?: ${ghr_has_projects_disp}
       Has wiki?: ${ghr_has_wiki_disp}

          GitHub: ${ghr_html_url}
        Homepage: ${ghr_homepage}
     Description: ${ghr_description}

   Clone via ssh: ${ghr_ssh_url}
 Clone via https: ${ghr_clone_url}
EOF

exit 0


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='ads-github-tools' \
#               --release='ads-github-tools-0.3.1' \
#               --section='1' \
#               > /outputdir/ads-github-repo-create.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=encoding utf8

=head1 NAME

  ads-github-repo-create - Create a new GitHub repository


=head1 SYNOPSIS

  ads-github-repo-create (-h | --help)
  ads-github-repo-create (-V | --version)
  ads-github-repo-create [(-v | --verbose)] [(-p | --private)] [--force-replace]
                         [(-O <word> | --output-format=<word>)]
                         [(-b <name> | --default-branch=<name>)]
                         [(-I | --disable-issues)]
                         [(-P | --disable-projects)]
                         [(-W | --disable-wiki)]
                         [(-d <blurb> | --description=<blurb>)]
                         [--homepage=<url>]
                         [--]
                         REPO_NAME

=head1 DESCRIPTION

The C<ads-github-repo-create> program is part of the C<ads-github-tools>
project.

The C<ads-github-repo-create> program allows one to create a new GitHub
repository from the command line. Knobs are provided for configuring most of
the attributes available for modification, as described below.


=head1 OPTIONS

Below are the command line options currently accepted by
C<ads-github-repo-create>.


=over 4

=item --help

Print help usage message


=item -b, --default-branch=NAME

Specify the name to use for the default git branch.

If not specified, the value of the L<git-config(1)> C<init.defaultBranch> key
will be used (from the "global" or "system" scopes only), if
available. Otherwise the default used by GitHub will be applied; since
2020-10-01, that default branch name is C<main>.


=item -d, --description=BLURB

Specify a short description blurb for the repo.


=item --force-replace

If a repo already exists with the specified name, the default behavior of the
program is to report the sitation in an error message and exit with a non-zero
status.

This option allows you to override that default behavior, and instead attempt
to replace the existing repository with a newly created one. The sequence of
operations performed to do so is basically a delete followed by a create.

Note that successfully performing this operation requires the use of a
personal access token that has the GitHub C<delete_repo> scope.


=item --homepage=URL

Specify a URL with more information about the repo. This is where you would
specify the URL to a related website.


=item -I, --disable-issues

Disable the GitHub issues feature for the new repo. By default, newly created
GitHub repositories have an associated "Issues" dashboard. If you do not need
it, then you can disable it at creation time using this option. Note that you
can always re-enable the issues dashboard at a later time.


=item -P, --disable-projects

Disable the GitHub projects feature for the new repo. By default, newly
created GitHub repositories have an associated "Projects" dashboard. If you do
not need it, then you can disable it at creation time using this option. Note
that you can always re-enable the projects dashboard at a later time.

=over 4

B<CAVEAT:> At the time of writing (2020-10), the GitHub v3 repo creation API
seems to be ignoring the C<has_projects> parameter key, so the projects
feature may not actually be disabled on the newly created repo. Since this
feature is not critical and likely won't see much use, the workaround for now
just is to carefully inspect the output of C<ads-github-repo-create>; if
needed, go into the GitHub web UI to disable the projects dashboard for the
newly created repo.

=back


=item -O, --output-format=WORD

Request that C<ads-github-repo-create> emit output in the format specified by
WORD.

Valid values for WORD include C<text> and C<json>.

The default, C<text>, is suitable for a human working in an interactive shell
session in a terminal.

The C<json> output shows the raw JSON representation for the newly created
repo, as provided by the GitHub API's endpoint:

    GET /repos/:owner/:repo

The C<json> output data structure contains more information than is presented
by the C<text> output.


=item -p, --private

Make the repository a GitHub private repo.

By default, newly created GitHub repositories are public. This option allows
you to request that the newly created repo have only private visibility,
instead.


=item -V, --version

Print the version of the program to stdout and then exit.


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
fruther the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item  -W, --disable-wiki

Disable the GitHub wiki feature for the new repo. By default, newly created
GitHub repositories have an associated wiki. If you do not need the wiki, then
you can disable it at creation time using this option. Note that you can
always re-enable the wiki at a later time.


=item --

Signals the end of options and disables further options processing. This can
(theoretically) be used to create a repository whose name would otherwise look
like a command line option to the C<ads-github-repo-create> program.

=back


=head1 EXIT STATUS

Exits with zero on success, non-zero on error.


=head1 EXAMPLES

=head2 Example 1: Default C<text> output with all default settings

This example shows the simplest invocation, which is simply to provide the
name of the new GitHub repository that is to be created:

    $ ads-github-repo-create 'aljunk-testing-repo-006'
    Summary of newly created repository:

                Name: aljunk-testing-repo-006
            Is fork?: no
               Owner: salewski

        Is archived?: no
        Is disabled?: no

          Created at: 2020-10-09 07:09:52+0000
          Updated at: 2020-10-09 07:09:56+0000

         Is private?: no
          Visibility: -

      Default branch: main

         Has issues?: yes
       Has projects?: yes
           Has wiki?: yes

              GitHub: https://github.com/salewski/aljunk-testing-repo-006
            Homepage: -
         Description: -

       Clone via ssh: git@github.com:salewski/aljunk-testing-repo-006.git
     Clone via https: https://github.com/salewski/aljunk-testing-repo-006.git


=head2 Example 2: Default C<text> output with customized settings

This example requests: a private repo (C<-p>), a default branch named "whatev"
(C<-b>), that the issues and wiki features be disabled (C<-I> and C<-W>,
respectively), and that the new repo have "la la la" as its description
(C<-d>):

    $ ads-github-repo-create -p -b 'whatev' -I -W -d 'la la la' -- 'aljunk-testing-repo-007'
    Summary of newly created repository:

                Name: aljunk-testing-repo-007
            Is fork?: no
               Owner: salewski

        Is archived?: no
        Is disabled?: no

          Created at: 2020-10-09 07:12:03+0000
          Updated at: 2020-10-09 07:12:07+0000

         Is private?: yes
          Visibility: -

      Default branch: whatev

         Has issues?: no
       Has projects?: yes
           Has wiki?: no

              GitHub: https://github.com/salewski/aljunk-testing-repo-007
            Homepage: -
         Description: la la la

       Clone via ssh: git@github.com:salewski/aljunk-testing-repo-007.git
     Clone via https: https://github.com/salewski/aljunk-testing-repo-007.git


=head1 SEE ALSO

=over 4

=item * L<ads-github-tools(7)>

=item * L<ads-github-whoami(1)>

Used to obtain the GitHub username of the authenticated user. The username
value (a.k.a. "owner" or "login") is used as a parameter in some of the GitHub
v3 API URLs that are invoked.

=back


=head1 HISTORY

The C<ads-github-repo-create> program first appeared in
C<ads-github-tools-0.3.1>, which was released in October 2020.


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <ads@salewski.email>

=back


=head1 BUGS

=over 4

=item * C<-P> (C<--dislable-projects>) does not work

This is actually a bug in the GitHub v3 API. See caveat documented above for
the C<-P> (C<--disable-projects>) option.


=item * Repo description text length is not checked

The GitHub v3 API documentation does not specify the maximum length of the
C<description> parameter, noting only that it should be a "short description
of the repository". We could probably figure out the actual limit by
experimentation, and at the very least impose our own "reasonable"
limit. However, at the moment, any value provided on the command line is
submitted "as is".


=item * Does not support the parameter: C<team_id>

The GitHub v3 repo creation API has a C<team_id> paramater that allows the
caller to specify the id of the "team" that will be granted access to this
repository. The parameter is only valid when creating a repository in a GitHub
"organization", and is not currently supported by C<ads-github-repo-create>.


=item * Does not support the parameter: C<visibility=(public|private|internal)>

At the time of writing, the 'visibility' parameter is only in preview in the
GitHub v3 API. If this feature is important to you, feel free to open an issue
for it.

=back

There are probably tons of other bugs, too. If you find any, please report
them as described in the C<BUGS> file.


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut
